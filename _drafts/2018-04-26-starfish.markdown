---
layout:     post
title:      "未来的计划？"
subtitle:   "Starfish"
date:       2018-04-26
author:     "mingjie"
header-img: "img/post-bg-jpynb.jpg"
tags:
    - learning

---

废话就不讲那么多了，先直接开始讲论文。

$$ f_\lambda $$：无限精度分辨率的模型光谱

$$ M(\Theta) $$：$$ f_\lambda $$被光谱仪采样之后的光谱

理论上来说到这一步就可以直接比较观测光谱$$ D $$与$$ M(\Theta) $$了，但是$$ D $$还包含了一些我们不想要的元素，比如边缘连续谱的扭曲之类的。我们用一些多余的参数去修改$$ M(\Theta) $$。

$$ M(\Theta, \phi_\mathrm{P}) = \{M_o(\Theta) \times P_o \} = \{M_o(\Theta) \times \sum_n c_o^{(n)} T_o^{(n)} \}$$

意思就是与其将观测光谱归一化，不如改变模型。

### 观测与模型的比较

$$ R = R(\Theta, \phi_\mathrm{P}) = D - M(\Theta, \phi_\mathrm{P}) $$

这还是个向量，当然不能拿来判断好坏。但是简单地拿它的2范数又会有简并以及解决不了有关联的误差的问题，所以我们用这个：

$$ p(D|M) = \frac{1}{\sqrt{(2\pi)^{N_\mathrm{pix}} \det{(C)}}} \exp{-0.5 R^T C^{-1} R} $$

引入一个矩阵$$ C $$，为测量误差和$$ R $$协方差的和，就可以同时兼顾这两个因素了。$$ R $$的协方差不为0的原因一个是line-spread function在采样的时候会包含一部分旁边像素的信息，二是模型有缺陷，在某些地方有系统的偏差。当然第一个原因也意味着它所造成的协方差应该随着像素的距离而减小（当然也要看LSF多宽）。

#### $$ C $$

显然重点在这个$$ C $$上面。一般的光谱都会在LSF上采样不止一次（两次或者三次），所以相邻的像素基本上是不独立的，自然残差也不是（比如图4就和泊松分布不一致）。所以我们可以区分独立的噪声和不独立的残差。但是数学上来说，不独立的残差可以看作是不独立的噪声，所以这就是它能被$$ C $$包含的原因。

刚刚也说了这个不独立噪声振幅小、宽度也小。我们用(9)式来计算这个两像素之间的“距离”（**为什么用这样的形式？**），用(11)来计算$$ C $$的第二部分。要注意的是(11)里面出现了两个超参数。

这个不独立残差虽然振幅小、宽度小，但是因为每个像素和附近的像素都是不独立的，所以这个它是整体存在于整个光谱上的，作者将它称之为Global Covariance Structure。图5的中间就是单纯的测量误差加上了全局结构之后的$$ C $$以及由它产生的模拟光谱的$$ 3\sigma $$band。可以看到它更好地描述了光谱的起伏。

Local Covariance Structure。有全局就有局部，模型是会出错的，如果某条谱线的$$ \log{gf} $$值搞错了那么在其他部分完美匹配的情况下，这条谱线肯定合不起来（图6）。那么怎么定量计算这个结构并把它挑出来呢？

既然是局部，协方差矩阵就不止和距离有关，还应该和波长本身有关。当我们假设模型的缺陷只会导致谱线深度发生变化的时候，那一个高斯就可以描述了(13)。(13)里面的$$ r $$应该是2范数？然后把它代进(10)里面再全部加起来就有协方差矩阵了。例子见图6。其实这是一个自动的outlier拒绝办法，不用手动去做。*还有一个好处在于它可以用于描述别的特征，比如晚型星的分子线，只要用合适的kernel就行了。*

**问题：你怎么知道哪个是拟合参数选得不好哪个是模型不好呢？**

注意这两个协方差矩阵在算好之后要分别加一个Hann窗(12)，减少计算量。

最后把这几个加起来就好了。如果对测量误差不满意的话就乘个系数。

### 先验

贝叶斯嘛，肯定有先验。如果我们有别的数据的话当然可以加上，要不然就在物理允许的范围内均匀就行。早型星的连续谱先验可以放飞自我，但是晚型星的就要保证它不要把一些宽的线也改掉了。第二是局部结构的宽度最好不要太宽，把稍微宽的特征交给全局结构去做。

### 具体过程（后验）

MCMC。设定一个初值，固定所有的$$ \phi $$然后找到最好的$$ \Theta $$，然后倒过来找$$ \phi $$。对于局部结构，我们比较观测的和只包含全局结构的平均光谱，然后如果偏离大于一个阈值就设为一个局部结构。在循环中局部结构的位置并不会丢，而是不断增加。当局部结构消失的时候，振幅也会变成0，没所谓。

计算要挺久的，不过可以并行化。也可以先算出其它参数然后固定，只变恒星参数

### 栗子

基本上要知道的就是我们的模型有一个更准确的误差估计，同时更精确的参数值（因为不管了一些不好的线）。更准确的误差估计好处在于不用认为定一个误差下限，还不correlated

### 以后要做的东西

不同数据集的比较，现在一般是直接拿结果来平均。更好的做法是同时模拟它们的数据。

某些对光谱无明显影响的参数：logg什么的。要不就调先验，加上别的测量，或者看Brewer2015。

不同模型的不同假设。没有好的方法，希望以后模型能接收数据到的结论来修改。

还有一些小的问题：有些参数根本没有被考虑

### 附录：光谱模拟器

之前已经讲过简单的光谱插值会带来一些问题，特别是会导致恒星参数聚集在格点附近，降低准确度同时给出不真实的过小的误差。对于一套恒星参数，这种插值只能给出一条光谱，但是这里的光谱模拟器可以给出很多不同光谱的概率分布，所以可以传递误差。

具体做法就是将模板光谱拆成很多个本征光谱，然后用高斯过程对每个本征光谱的权重进行插值，给出需要的光谱。高斯过程就能给处概率分布了。

来看看具体过程。我们用主成份分析的方法来得到本征光谱。如果有先验的话可以不将所有的模板光谱都丢进去，而是只取一部分模板光谱。然后所有模板光谱会被进行“正规化”，减去它们的平均值并且除以误差：

$$ \xi_\mu = \frac{1}{M}\sum_{i=1}^M f_\lambda (\{\theta_*\}_i^\mathrm{grid}) $$

$$ \xi_\sigma = \sqrt{\frac{1}{M}\sum_{i=1}^M [f_\lambda (\{\theta_*\}_i^\mathrm{grid}) - \xi_\mu]^2} $$

$$ \hat{f_\lambda} (\{\theta_*\}_i^\mathrm{grid}) = \frac{f_\lambda (\{\theta_*\}_i^\mathrm{grid}) - \xi_\mu}{\xi_\sigma} $$

然后根据Ivezic et al. 2013利用PCA计算本征光谱，取前m个使得还原的光谱误差小于2%。那么光谱可以被表示为：

$$ f_\lambda (\{\theta_*\}_i^\mathrm{grid}) \approx \xi_\mu + \xi_\sigma \sum_{k=1}^m w_k (\{\theta_*\}_i^\mathrm{grid})\xi_k $$

$$ w_k (\{\theta_*\}_i^\mathrm{grid}) = \sum_\lambda \hat{f_\lambda} (\{\theta_*\}_i^\mathrm{grid}) \xi_k $$

或者像(27)那样写成向量。下一步就是对权重w的内插了。
