<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mingjie's Blog</title>
    <description>Write everything, think everything.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 29 May 2018 20:59:28 +0900</pubDate>
    <lastBuildDate>Tue, 29 May 2018 20:59:28 +0900</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>OASP笔记 - 11</title>
        <description>&lt;p&gt;看了这么久从这一章开始才是正餐。&lt;/p&gt;

&lt;p&gt;谱线的强度和形状都是我们很关心的东西，因为它们可以同时受多个物理量影响；相反连续谱的形状基本上只是有效温度的函数。谱线吸收系数就决定了这条谱线位于什么波长、将会有什么形状。&lt;/p&gt;

&lt;p&gt;这一章我们基本上讨论三种谱线致宽的机制：自然致宽、压强致宽以及热运动致宽。虽然字面上看起来这三个机制只会告诉我们谱线宽了多少，但是实际上我们会推导出谱线吸收系数，也就把能定的都定下来了。从结论上来说前两个致宽是一个洛仑兹轮廓，最后一个是高斯轮廓；然后把它们卷积起来就得到最终的轮廓了。&lt;/p&gt;

&lt;h3 id=&quot;自然致宽&quot;&gt;自然致宽&lt;/h3&gt;

&lt;p&gt;吸收嘛，肯定得有入射光&lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt;和吸收光的原子。光作为电磁波有波动方程以及光速的关系：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial^2 E}{\partial t^2} = v^2 \frac{\partial^2 E}{\partial x^2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v = c\left(\frac{\epsilon_0 \mu_0}{\epsilon \mu}\right)^{1/2}&lt;/script&gt;

&lt;p&gt;而且光可以叠加，为了简单起见只考虑其中的一个成分：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E = E_0 e^{-2\pi i (x/\lambda-t/P)} = E_0 e^{-2\pi i (x-vt)/\lambda} = E_0 e^{-i\omega (x/v-t)} \tag{11.1}&lt;/script&gt;

&lt;p&gt;我们忽略磁场，就有&lt;script type=&quot;math/tex&quot;&gt;\mu = \mu_0&lt;/script&gt;。但是因为吸收光的原子是一个个电偶极子，所以介电常数发生了变化：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\epsilon}{\epsilon_0} = \frac{E + 4\pi Nqz}{E} = 1 + \frac{4\pi Nqz}{E} \tag{11.2}&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;为电偶极子数密度、&lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;为电偶极子电量（之后一般会换成&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;）、&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;为电偶极子长度。把电偶极子看成谐振子(&lt;script type=&quot;math/tex&quot;&gt;\frac{d^2 z}{dt^2}&lt;/script&gt;)，加上驱动力(&lt;script type=&quot;math/tex&quot;&gt;\omega_0^2 z&lt;/script&gt;)和阻尼(&lt;script type=&quot;math/tex&quot;&gt;\gamma \frac{dz}{dt}&lt;/script&gt;)，就有振动方程：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{d^2 z}{dt^2} + \gamma \frac{dz}{dt} + \omega_0^2 z = \frac{e}{m} E_0 e^{i\omega t} \tag{11.3}&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x = 0&lt;/script&gt;时方程有解为&lt;script type=&quot;math/tex&quot;&gt;z = z_0 e^{i\omega t}&lt;/script&gt;，所以&lt;script type=&quot;math/tex&quot;&gt;\dot{z} = i\omega z, \ddot{z} = -\omega^2 z&lt;/script&gt;，方程变为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;-\omega^2 z + \gamma i\omega z + \omega_0^2 z = \frac{e}{m} E_0 e^{i\omega t}&lt;/script&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z = \frac{e}{m} \frac{E_0 e^{i\omega t}}{\omega_0^2 - \omega^2 + i\gamma\omega} = \frac{e}{m} \frac{E}{\omega_0^2 - \omega^2 + i\gamma\omega}&lt;/script&gt;

&lt;p&gt;可以看到&lt;script type=&quot;math/tex&quot;&gt;\omega = \omega_0&lt;/script&gt;的时候振幅最大，被称为共振频率，也是谱线所在的地方。将这个结果代回(11.2)，就有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\epsilon}{\epsilon_0} = 1 + \frac{4\pi Ne^2}{m}\frac{1}{\omega_0^2 - \omega^2 + i\gamma\omega}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align} \frac{c}{v} = \left(\frac{\epsilon}{\epsilon_0}\right)^{1/2} &amp;\approx 1 + \frac{1}{2} \frac{4\pi Ne^2}{m}\frac{1}{\omega_0^2 - \omega^2 + i\gamma\omega} \\
&amp;= 1 + \frac{2\pi Ne^2}{m}\left[\frac{\omega_0^2-\omega^2}{(\omega_0^2-\omega^2)^2 + \gamma^2\omega^2} - i\frac{\gamma\omega}{(\omega_0^2-\omega^2)^2 + \gamma^2\omega^2}\right]
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;我们希望将这个量代回场强那里，然后求光强；而光强是场强实部的平方，所以可以只考虑上式中的虚部，有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I = I_0 e^{-2k\omega x/c} = I_0 e^{-l_\nu \rho x}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;l_\nu \rho = \frac{4\pi Ne^2}{mc} \frac{\gamma\omega^2}{(\omega_0^2-\omega^2)^2 + \gamma^2\omega^2} \tag{11.5}&lt;/script&gt;

&lt;p&gt;考虑到谱线轮廓很小，&lt;script type=&quot;math/tex&quot;&gt;\omega \approx \omega_0&lt;/script&gt;，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\omega_0^2 - \omega^2 = (\omega_0-\omega)(\omega_0+\omega) \approx 2\omega \Delta\omega&lt;/script&gt;

&lt;p&gt;所以&lt;script type=&quot;math/tex&quot;&gt;(11.5)&lt;/script&gt;就变成了&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;l_\nu \rho = \frac{2\pi Ne^2}{mc} \frac{\gamma}{\Delta\omega^2 + (\gamma/2)^2} \tag{11.6}&lt;/script&gt;

&lt;p&gt;这是某个圆频率下单位体积内的总吸收，而如果我们想计算单个原子的吸收的话，有&lt;script type=&quot;math/tex&quot;&gt;l_\nu \rho = N \alpha&lt;/script&gt;，&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
  \alpha &amp;= \frac{2\pi e^2}{mc} \frac{\gamma}{\Delta\omega^2 + (\gamma/2)^2} \\
  &amp;= \frac{e^2}{mc} \frac{\gamma/4\pi}{\Delta\nu^2 + (\gamma/4\pi)^2} \\
  &amp;= \frac{e^2}{mc} \frac{\lambda^2}{c} \frac{\gamma\lambda^2/4\pi}{\Delta\lambda^2 + (\gamma\lambda^2/4\pi c)^2} \tag{11.7}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;分别在圆频率、频率和波长下。这就是主要的结果了，也是一个洛仑兹轮廓。不知道的话请看&lt;a href=&quot;https://mingjiejian.github.io/2017/11/11/OASP2/&quot;&gt;第二章&lt;/a&gt;。这个轮廓的宽度由阻尼系数&lt;script type=&quot;math/tex&quot;&gt;\gamma&lt;/script&gt;决定。&lt;/p&gt;

&lt;p&gt;洛仑兹轮廓的积分为&lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;，所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_0^\infty \alpha d\nu = \int_{-\infty}^\infty \alpha d\Delta\nu = \frac{\pi e^2}{mc} \tag{11.8}&lt;/script&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_0^\infty \alpha d\lambda = \frac{\pi e^2}{mc} \frac{\lambda^2}{c} \tag{11.9}&lt;/script&gt;

&lt;p&gt;着个量指的是一个原子每秒每平方弧度（只有一个方向）所吸收的光的比例。实际上的比例比上两式要小，这是因为在推导的过程中我们没有考虑量子力学带来的修正。假设这个修正量为&lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;，上面的积分同时意味着原子发生吸收的概率，也就是&lt;script type=&quot;math/tex&quot;&gt;B_{lu}h\nu (5.17)&lt;/script&gt;，所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_0^\infty \alpha d\nu = \frac{\pi e^2}{mc}f = B_{lu}h\nu&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Rightarrow f = \frac{mc}{\pi e^2} B_{lu}h\nu = 7.484 \times 10^{-7} \frac{B_{lu}}{\lambda} \tag{11.11}&lt;/script&gt;

&lt;p&gt;用&lt;script type=&quot;math/tex&quot;&gt;(6.8)&lt;/script&gt;将&lt;script type=&quot;math/tex&quot;&gt;B_{lu}&lt;/script&gt;换成&lt;script type=&quot;math/tex&quot;&gt;A_{lu}&lt;/script&gt;，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f = \frac{mc^3}{2\pi e^2\nu^2} \frac{g_u}{g_l}A_{ul} = 1.884 \times 10^{-15} \lambda^2 \frac{g_u}{g_l} A_{ul} \tag{11.12}&lt;/script&gt;

&lt;p&gt;如果我们只考虑受激辐射的话，可以写出类似的公式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f_\mathrm{em} = \frac{mc}{\pi e^2} B_{ul}h\nu&lt;/script&gt;

&lt;p&gt;所以有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;g_u f_\mathrm{em} = g_l f_\mathrm{abs}&lt;/script&gt;

&lt;p&gt;因此很多实际的表格会给出&lt;script type=&quot;math/tex&quot;&gt;gf&lt;/script&gt;而不是单纯的&lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;以避免歧义。多数的&lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;值都是测出来的，不过有些简单的比如氢原子有公式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f = \frac{2^5}{3^{3/2}\pi} \frac{g_\mathrm{bb}}{l^5u^3} \left( \frac{1}{l^2} - \frac{1}{u^2} \right)^{-3}&lt;/script&gt;

&lt;h4 id=&quot;自然致宽的阻尼常数&quot;&gt;自然致宽的阻尼常数&lt;/h4&gt;

&lt;p&gt;知道了自然致宽是一个洛仑兹轮廓之后，只要知道阻尼常数&lt;script type=&quot;math/tex&quot;&gt;\gamma&lt;/script&gt;就可以确定轮廓了。Menzal (1961)给出了阻尼常数的方程：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{dW}{dt} = -\frac{2}{3}\frac{e^2\omega^2}{mc^3}W = -\gamma W&lt;/script&gt;

&lt;p&gt;所以可以得出&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\gamma = \frac{2e^2\omega^2}{3mc^3} = \frac{0.22}{\lambda^2}&lt;/script&gt;

&lt;p&gt;当然后面的等号需要&lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;的单位为厘米。把&lt;script type=&quot;math/tex&quot;&gt;\gamma&lt;/script&gt;和它的变式放回&lt;script type=&quot;math/tex&quot;&gt;(11.7)&lt;/script&gt;就可以算出不同自变量下的轮廓宽度了。可以看到在&lt;script type=&quot;math/tex&quot;&gt;\Delta \lambda&lt;/script&gt;下，所有谱线的宽度都是一样的，&lt;script type=&quot;math/tex&quot;&gt;0.59\times 10^{-4}&lt;/script&gt;埃。&lt;/p&gt;

&lt;p&gt;同样也需要引入量子力学的修正。一个现象学的方法就是将能级的能量&lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt;看作很多个分立的小能级之和，&lt;script type=&quot;math/tex&quot;&gt;W = N_uh\nu&lt;/script&gt;，那么&lt;script type=&quot;math/tex&quot;&gt;(11.13)&lt;/script&gt;可以被写成&lt;script type=&quot;math/tex&quot;&gt;dN_u/dt = -\gamma N_u&lt;/script&gt;。同时能级占据数对时间的导数也是跃迁的概率，所以&lt;script type=&quot;math/tex&quot;&gt;dN_u/dt = -4\pi A_{ul} N_u&lt;/script&gt;。考虑所有可能的跃迁，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\gamma_u = 4\pi \sum_{l&lt;u} A_{ul} %]]&gt;&lt;/script&gt;

&lt;p&gt;这个爱因斯坦系数可以和海森堡不确定原理联系起来。不确定原理告诉我们&lt;script type=&quot;math/tex&quot;&gt;\Delta W_u \Delta t \gtrsim h/2\pi&lt;/script&gt;，而&lt;script type=&quot;math/tex&quot;&gt;\Delta t = 1/\sum 4\pi A_{ul}&lt;/script&gt;，因为&lt;script type=&quot;math/tex&quot;&gt;A_{ul}&lt;/script&gt;代表着1秒内跃迁的概率。所以&lt;script type=&quot;math/tex&quot;&gt;\Delta W_u \gtrsim 2h \sum A_{ul}&lt;/script&gt;，也就是每个能级都有一个宽度。&lt;/p&gt;

&lt;p&gt;那么跃迁总不是一个能级的事情，所以谱线的自然致宽阻尼常数是两个能级的轮廓卷积。从第二章我们知道&lt;script type=&quot;math/tex&quot;&gt;\gamma = \gamma_u + \gamma_l&lt;/script&gt;。如果辐射场很强的话，我们还要考虑受激辐射和吸收的问题：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\gamma_u = 4\pi \sum A_{ul} + 4\pi \sum I_\nu B_{ul} + 4\pi \sum I_\nu B_{uk}&lt;/script&gt;

&lt;p&gt;这样会更全面一点。&lt;/p&gt;

&lt;h3 id=&quot;压力致宽&quot;&gt;压力致宽&lt;/h3&gt;

&lt;p&gt;压力致宽其实挺好理解，原子被别人撞了（在别的粒子附近），能级就变了，会带来谱线移动、不对称性和致宽。因为是在别的粒子附近，所以实际上是粒子的电场使得原子的能级发生变化，一般指的是斯塔克效应(Stark effect)。同时粒子离原子越近(&lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt;越小)，影响(&lt;script type=&quot;math/tex&quot;&gt;\Delta W&lt;/script&gt;)应该就越大；根据这个思想我们可以写出这样的一条式子：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta W = c/R^n \tag{11.16}&lt;/script&gt;

&lt;p&gt;至于&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;是多少，就取决于粒子的种类了；一般的作用如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;种类&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;影响的谱线&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;粒子&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;线性斯塔克效应&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;氢线&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;光子、电子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;共振致宽&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;同种原子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;二次斯塔克效应&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高温恒星中的多数谱线&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;离子、电子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;范德瓦尔斯效应&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低温恒星中的多数谱线&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;中性氢&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;把上面的能级能量变化转为谱线频率的变化，可以得出&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \nu = C_n / R^n \tag{11.17}&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;C_n&lt;/script&gt;需要被测出来。&lt;/p&gt;

&lt;h4 id=&quot;简化&quot;&gt;简化！&lt;/h4&gt;

&lt;p&gt;貌似到这里我们还没能给出谱线轮廓，怎么办？当然是简化了。假设碰撞是绝热的，也就是碰撞不会导致跃迁；同时因为恒星大气比较稀薄，我们认为碰撞的时间远远短于两次碰撞的时间(impact apprximation)。&lt;/p&gt;

&lt;p&gt;我们把一个光子看成一个长为&lt;script type=&quot;math/tex&quot;&gt;W = \Delta t&lt;/script&gt;的方波，那么它的光谱就是&lt;script type=&quot;math/tex&quot;&gt;\mathrm{sinc}^2{\pi\Delta t (\nu - \nu_0)}&lt;/script&gt;，宽度为&lt;script type=&quot;math/tex&quot;&gt;\Delta \nu = 1 / \Delta t&lt;/script&gt;。现在吸收这个光子的原子被另外的粒子影响，而且影响的大小不断在变化，那么我们就将这个光子分成很多小份（小的方波&lt;script type=&quot;math/tex&quot;&gt;\Delta t_j&lt;/script&gt;），每个小份之间的相位不在一样，就需要独立地看待了。当然这个时候小份光的光谱就变宽了(&lt;script type=&quot;math/tex&quot;&gt;\Delta \nu_j = 1 / \Delta t_j&lt;/script&gt;)。&lt;/p&gt;

&lt;p&gt;回到宏观的视角，每一次碰撞的&lt;script type=&quot;math/tex&quot;&gt;\Delta t_j&lt;/script&gt;都是不一样的，那么最后中的谱线宽应该为&lt;script type=&quot;math/tex&quot;&gt;\Delta t_j&lt;/script&gt;对应的sinc函数乘上它的概率再对所有的&lt;script type=&quot;math/tex&quot;&gt;\Delta t_j&lt;/script&gt;积分。通过简单的推理可得&lt;script type=&quot;math/tex&quot;&gt;\Delta t_j&lt;/script&gt;的分布为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;dP(\Delta t_j) = e^{-\Delta t_j/\Delta t_0} d\Delta t_j/\Delta t_0&lt;/script&gt;

&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;\Delta t_0&lt;/script&gt;是典型的碰撞间隔时间。所以原子吸收系数就是：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha = \int_0^\infty \Delta t^2 \left( \frac{\sin{\pi \Delta t (\nu-\nu_0)}}{\pi \Delta t (\nu-\nu_0)} \right)^2 e^{-\Delta t_j/\Delta t_0} d\Delta t_j/\Delta t_0&lt;/script&gt;

&lt;p&gt;积分的结果（理所当然地）是一个洛仑兹轮廓：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha = \frac{\mathrm{constant}}{4\pi^2(\nu-\nu_0)^2 + (1/\Delta t_0)^2} = \mathrm{constant} \frac{\gamma_n/4\pi}{(\nu-\nu_0)^2 + (\gamma_n/4\pi)^2} \tag{11.19}&lt;/script&gt;

&lt;h4 id=&quot;压力致宽的阻尼系数&quot;&gt;压力致宽的阻尼系数&lt;/h4&gt;

&lt;p&gt;从上面可以看出来&lt;script type=&quot;math/tex&quot;&gt;\gamma_n = 2/\Delta t_0&lt;/script&gt;，那就是要算&lt;script type=&quot;math/tex&quot;&gt;\Delta t_0&lt;/script&gt;了；不过这里我们要绕一个圈子。&lt;/p&gt;

&lt;p&gt;考虑谱线频率的累积变化：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi = 2\pi \int_0^\infty \Delta \nu dt = 2\pi \int_0^\infty C_n R^{-n} dt \tag{11.20}&lt;/script&gt;

&lt;p&gt;先只考虑一个粒子，做直线运动，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi = 2\pi \int_0^\infty C_n \frac{cos^n{\theta}}{\rho^n} dt&lt;/script&gt;

&lt;p&gt;&lt;em&gt;需要有图&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;换元什么的，&lt;script type=&quot;math/tex&quot;&gt;v = dy/dt = (\rho/\cos{\theta})d\theta/dt, dt = (\rho/v)d\theta/\cos^2{\theta}&lt;/script&gt;，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi = \frac{2\pi C_n}{v\rho^{n-1}} \int_{-\pi/2}^{\pi/2} \cos^{n-2}{\theta} d\theta \tag{11.21}&lt;/script&gt;

&lt;p&gt;这个积分在某些&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;的值如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;n&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\int_{-\pi/2}^{\pi/2} \cos^{n-2}{\theta} d\theta&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\pi/2&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;4/3&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;3\pi/8&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们很随意地确定一个阈值，&lt;script type=&quot;math/tex&quot;&gt;\phi = 1 \mathrm{rad}&lt;/script&gt;，得到一个临界半径：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\rho_0 = \left[ \frac{2\pi C_n}{v} \int_{-\pi/2}^{\pi/2} \cos^{n-2}{\theta} d\theta \right]^{1/(n-1)} \tag{11.22}&lt;/script&gt;

&lt;p&gt;然后我们只考虑那些相位差超过1个弧度，也就是距离小于临界半径的那些碰撞。在&lt;script type=&quot;math/tex&quot;&gt;\Delta t_1&lt;/script&gt;的时间内，这样的碰撞应该有&lt;script type=&quot;math/tex&quot;&gt;\pi \rho_0^2 v N \Delta t_1&lt;/script&gt;次。那么当我们让&lt;script type=&quot;math/tex&quot;&gt;\Delta t_1 = \Delta t_0&lt;/script&gt;时，应该只有1次碰撞。所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\gamma_n = \frac{2}{\Delta t_0} = 2\pi \rho_0^2 v N \tag{11.23}&lt;/script&gt;

&lt;p&gt;上式就剩一个平均相对速率&lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;不知道。其实就是Maxwell-Boltzmann分布的结论：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v = \left[ \frac{8kT}{\pi} \left( \frac{1}{m_A} + \frac{1}{m_p} \right) \right]^{1/2} \tag{11.24}&lt;/script&gt;

&lt;p&gt;其实&lt;script type=&quot;math/tex&quot;&gt;\gamma_n&lt;/script&gt;更准确的形式可以表示为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\gamma_n = N \int_{-\infty}^\infty vf(v)\sigma_n(v)dv \tag{11.25}&lt;/script&gt;

&lt;h4 id=&quot;两个例子&quot;&gt;两个例子&lt;/h4&gt;

&lt;p&gt;请自行推导，对于二次斯塔克效应以及范德瓦尔斯效应，有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\log{\gamma_4} \approx 19 + \frac{2}{3} \log{C_4} + \log{P_\mathrm{e}} - \frac{5}{6} \log{T} \tag{11.27}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\log{\gamma_6} \approx 20 + 0.4 \log{C_6} + \log{P_\mathrm{e}} - 0.7 \log{T} \tag{11.29}&lt;/script&gt;

&lt;p&gt;画出来就像下面这样：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;应该有图&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;上面这两条式子在谱线计算里面经常会被用到。当然实际和理论还是有点区别，所以会加一个系数，随时修正。&lt;/p&gt;

&lt;h3 id=&quot;氢线的致宽&quot;&gt;氢线的致宽&lt;/h3&gt;

&lt;p&gt;见过谱线的同学们应该都知道，氢线的致宽和其他线的致宽根本不在一个量级上。这是因为氢线致宽的因素主要是线性斯塔克效应。那么应该怎么去计算氢线的致宽呢？&lt;/p&gt;

&lt;p&gt;与压力致宽的想法类似，我们从下式开始：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \lambda_j = c_j E \tag{11.31}&lt;/script&gt;

&lt;p&gt;最早我们只考虑了一次电离离子的影响(&lt;script type=&quot;math/tex&quot;&gt;E = e/R^2&lt;/script&gt;)，同时因为平方反比下降，我们只考虑距离氢原子最近的那个离子。此时在半径为&lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt;的球面上找到最近的离子的概率为不在球内的概率乘上在表面的概率：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(R)dR = P_N(R)4\pi R^2 N dR \tag{11.32}&lt;/script&gt;

&lt;p&gt;那么再次通过简单的推理得到在半径为&lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt;的球内找不到最近的离子的概率为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_n(R) = P_n(0)e^{-4\pi R^3N/3}&lt;/script&gt;

&lt;p&gt;考虑到&lt;script type=&quot;math/tex&quot;&gt;R = 0, P_n = 1&lt;/script&gt;以及定义&lt;script type=&quot;math/tex&quot;&gt;R_0 = (4\pi N/3)^{-1/3}&lt;/script&gt;，&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_n(R) = e^{-(R/R_0)^3}&lt;/script&gt;

&lt;p&gt;所以&lt;script type=&quot;math/tex&quot;&gt;(11.32)&lt;/script&gt;变为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(R)dR = 3 \frac{R^2}{R_0^3} e^{-(R/R_0)^3} dR&lt;/script&gt;

&lt;p&gt;或者换元成场强&lt;script type=&quot;math/tex&quot;&gt;\beta = E/E_0&lt;/script&gt;的话，&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(\beta)d\beta = \frac{3}{2} \beta^{-5/2} e^{-\beta^{-3/2}} d\beta \tag{11.34}&lt;/script&gt;

&lt;p&gt;就差不多了。当然更准确&lt;script type=&quot;math/tex&quot;&gt;P(\beta)&lt;/script&gt;也是有的，式子&lt;script type=&quot;math/tex&quot;&gt;(11.35)&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;现在轮廓已经有了，然后就是加上量子力学修正（暂时略，还没有很好的理解）。最后画出来就像图11.9一样。当然还有一些没有考虑：电子带来的致宽，在线翼处会很明显；还有其他氢原子带来的致宽，在中低温恒星中比较明显。&lt;/p&gt;

&lt;h3 id=&quot;热运动致宽&quot;&gt;热运动致宽&lt;/h3&gt;

&lt;p&gt;这个就简单了，高中生都知道的东西。多普勒致宽是因为有视向速度&lt;script type=&quot;math/tex&quot;&gt;v_R&lt;/script&gt;：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\Delta\lambda}{\lambda} = \frac{\Delta\nu}{\nu} = \frac{v_R}{c} \tag{11.38}&lt;/script&gt;

&lt;p&gt;由&lt;script type=&quot;math/tex&quot;&gt;(11.1)&lt;/script&gt;有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\mathrm{d}N(v_R)}{N} = \frac{1}{\pi^{1/2}v_0} e^{-(\frac{v_R}{v_0})^2} \mathrm{d}v_R&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;v_0^2 = 2kT/m&lt;/script&gt;，那么就有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \lambda_\mathrm{D} = \frac{v_0}{c}\lambda_0 = \frac{v_0}{c} \left( \frac{2kT}{m} \right) \tag{11.39}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \mu_\mathrm{D} = \frac{v_0}{c}\mu_0 = \frac{v_0}{c} \left( \frac{2kT}{m} \right) \tag{11.40}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\mathrm{d}N(\Delta\lambda)}{N} = \frac{1}{\pi^{1/2}\lambda_\mathrm{D}} e^{-(\frac{\Delta\lambda}{\lambda_\mathrm{D}})^2} \mathrm{d}\Delta\lambda \tag{11.41}&lt;/script&gt;

&lt;p&gt;转成能量就有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha d\lambda = \frac{\pi^{1/2}e^2}{mc} f \frac{\lambda_0^2}{c} \frac{1}{\Delta\lambda_\mathrm{D}} e^{-(\frac{\Delta\lambda}{\lambda_\mathrm{D}})^2} d\lambda \tag{11.42}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha d\nu = \frac{\pi^{1/2}e^2}{mc} f \frac{1}{\Delta\nu_\mathrm{D}} e^{-(\frac{\Delta\mu}{\nu_\mathrm{D}})^2} d\nu \tag{11.43}&lt;/script&gt;

&lt;p&gt;显然是个高斯轮廓。&lt;/p&gt;

&lt;h3 id=&quot;microturbulence&quot;&gt;Microturbulence&lt;/h3&gt;

&lt;p&gt;这东西我一直不知道怎么翻译比较好。这个东西指的是小尺度上的质量运动（谁的？），可以用宽度为&lt;script type=&quot;math/tex&quot;&gt;\xi&lt;/script&gt;的高斯分布描述。具体会在第17章讨论。&lt;/p&gt;

&lt;h3 id=&quot;将轮廓合起来&quot;&gt;将轮廓合起来&lt;/h3&gt;

&lt;p&gt;这也好说，卷卷卷卷卷积起来就好了：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha(\mathrm{total}) = \alpha(\mathrm{natural}) * \alpha(\mathrm{Stark}) * \alpha(\mathrm{v.d. Waals}) * \alpha(\mathrm{thermal}) * \alpha(\mathrm{micro}) \tag{11.44}&lt;/script&gt;

&lt;p&gt;前三个是一个宽为&lt;script type=&quot;math/tex&quot;&gt;\gamma = \gamma_\mathrm{natural} + \gamma_4 + \gamma_6&lt;/script&gt;的洛仑兹轮廓，后面两个的宽度是&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \lambda_\mathrm{D} = \frac{\lambda_0}{c} \left( \frac{2kT}{m} + \xi^2 \right) \tag{11.45}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \nu_\mathrm{D} = \frac{\nu_0}{c} \left( \frac{2kT}{m} + \xi^2 \right) \tag{11.45}&lt;/script&gt;

&lt;p&gt;最终&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
  \alpha &amp;= \frac{\pi e^2}{mc} f \frac{\gamma/4\pi^2}{\Delta\nu^2 + (\gamma/4\pi)^2} * \frac{1}{\pi^{1/2} \Delta\nu_\mathrm{D}} e^{-(\frac{\Delta\nu}{\nu_\mathrm{D}})^2} \\
  &amp;= \frac{\pi^{1/2}e^2}{mc} \frac{f}{\Delta\nu_\mathrm{D}}H(u,a) \\
  &amp;= \frac{\pi^{1/2}e^2}{mc} \frac{\lambda_0^2 f}{\Delta\lambda_\mathrm{D}}H(u,a) \tag{11.46}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;H(u,a)&lt;/script&gt;为Hjerting函数，自变量为&lt;script type=&quot;math/tex&quot;&gt;u = \Delta\nu/\Delta\nu_\mathrm{D} = \Delta\lambda/\Delta\lambda_\mathrm{D}&lt;/script&gt;，和&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
  a &amp;= \frac{\gamma}{4\pi} \frac{1}{\Delta\nu_\mathrm{D}} \\
  &amp;= \frac{\gamma}{4\pi} \frac{\lambda_0^2}{c} \frac{1}{\Delta\lambda_\mathrm{D}} \tag{11.47}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;当&lt;script type=&quot;math/tex&quot;&gt;a = 0&lt;/script&gt;时，Hjerting函数就变回高斯了。我们也可以用Voigt函数来表示Hjerting函数，&lt;script type=&quot;math/tex&quot;&gt;V(u,a) = H(u,a)/(\pi^{1/2}\Delta\nu_\mathrm{D}&lt;/script&gt;)。&lt;/p&gt;

&lt;p&gt;氢线的话，也是&lt;script type=&quot;math/tex&quot;&gt;(11.35)&lt;/script&gt;乘上Hjerting函数。&lt;/p&gt;

&lt;h3 id=&quot;差不多就是这样&quot;&gt;差不多就是这样&lt;/h3&gt;

&lt;p&gt;有些再多的就用到再来总结。&lt;/p&gt;
</description>
        <pubDate>Wed, 16 May 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/05/16/OASP11/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/16/OASP11/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>OASP笔记 - 10</title>
        <description>&lt;p&gt;又是比较简单的一章。而且因为连续谱一般和流量的绝对定标有关，我平常其实用得不多。&lt;/p&gt;

&lt;p&gt;连续谱的确定主要能匹配出有效温度来，如果细节多一些的话&lt;script type=&quot;math/tex&quot;&gt;\log{g}&lt;/script&gt;也可以确定。至于金属丰度就有点困难了，虽然也是有办法的。那么为了一次性地得到比较宽的光谱范围（毕竟高分辨率光谱需要更长的曝光时间，以及不同级数之间的流量定标相当麻烦），这里所说的连续谱的分辨率一般在10到15埃左右。在得到目标星光谱之后一般会有如下的流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;比较目标星和标准星光谱&lt;/li&gt;
  &lt;li&gt;校准标准星光谱的形状&lt;/li&gt;
  &lt;li&gt;校准标准星某一个/某几个波长上的绝对流量&lt;/li&gt;
  &lt;li&gt;考虑谱线对目标星连续谱的影响&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然书上是这么写，但是我觉得更好的顺序是2314，因为当考虑连续谱的绝对流量的时候没有校准好的标准星当然做不下去。&lt;/p&gt;

&lt;h3 id=&quot;光谱仪&quot;&gt;光谱仪&lt;/h3&gt;

&lt;p&gt;图片请参考&lt;a href=&quot;https://mingjiejian.github.io/2017/12/18/OASP3/&quot;&gt;第三章&lt;/a&gt;的图1。顺便从那里的&lt;script type=&quot;math/tex&quot;&gt;(3.15)&lt;/script&gt;可以得到&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \lambda = -\cos{\alpha} \frac{W'd}{f_\mathrm{coll}n}&lt;/script&gt;

&lt;p&gt;因为分辨率不高，所以为了增加进光量一般会把狭缝开到比恒星的像更大。这个时候狭缝宽度将被星像的线宽度&lt;script type=&quot;math/tex&quot;&gt;\Delta \phi F_\mathrm{eff}&lt;/script&gt;代替：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta \lambda = -\cos{\alpha} \frac{F_\mathrm{eff}d}{f_\mathrm{coll}n}\Delta \phi \tag{10.1}&lt;/script&gt;

&lt;p&gt;由上式可以看到视宁度会影响光谱仪的分辨率，不过可以通过减小&lt;script type=&quot;math/tex&quot;&gt;\frac{F_\mathrm{eff}}{f_\mathrm{coll}}&lt;/script&gt;来减小视宁度浮动的影响。&lt;/p&gt;

&lt;h3 id=&quot;大气消光&quot;&gt;大气消光&lt;/h3&gt;

&lt;p&gt;当我们观测目标星和标准星的地平高度（或者说天顶距）不一样的时候，我们需要考虑大气消光的影响。当如下的情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;平面平行层假设成立以及大气稳定&lt;/li&gt;
  &lt;li&gt;标准星不是变星&lt;/li&gt;
  &lt;li&gt;测得的有效波长不是天顶距的函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;成立时，就有最简单的流量与天顶距的关系：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_\nu = F_\nu^0 e^{\tau_\nu \sec{Z}}&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;F_\nu^0&lt;/script&gt;是大气层外的流量，&lt;script type=&quot;math/tex&quot;&gt;\tau_\nu&lt;/script&gt;是恒星在天顶时大气层的光深。取个导数再把标准星加上：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\log{\frac{F_\nu(2)}{F_\nu{(1)}}} = \log{\frac{F_\nu^0(2)}{F_\nu^0{(1)}}} - \tau_\nu \log{e(\sec{Z_2}-\sec{Z_1})} \tag{10.3}&lt;/script&gt;

&lt;p&gt;当然天顶距越接近肯定越好，这也是高分辨率光谱在做天光改正的时候需要地平高度尽量相近的标准星的原因。假设的第3点不成立的情况一般是大气消光对某个波段的短波/长波影响比较大，导致了天顶距小的时候所有光都透了过来，天顶距大了之后就只能看见长波的光了。当然在相对较高的分辨率下（小于50埃），这个问题基本不需要考虑。&lt;/p&gt;

&lt;h3 id=&quot;标准星的校准&quot;&gt;标准星的校准&lt;/h3&gt;

&lt;p&gt;标准星在不同波段的流量先相对于5556埃校准，然后我们再校准5556埃的绝对流量。标准星一般是织女星或者太阳。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.amazonaws.com/aasie/images/1538-3881/146/3/68/aj481013f4_hr.jpg&quot; alt=&quot;&quot; /&gt;
织女星的光谱&lt;/p&gt;

&lt;p&gt;上面的其实已经不只是连续谱，而是高分辨率光谱了。以前的低分辨率光谱在大于8500埃那里会有很大的弥散，就是因为Pashen线系的存在。&lt;/p&gt;

&lt;p&gt;要多说几句的是这种图横纵轴的单位是比较容易混淆的。光谱的话，我们关心的是每个波长/频率上的&lt;strong&gt;流量&lt;/strong&gt;是多少，所以&lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;要和&lt;script type=&quot;math/tex&quot;&gt;F_\lambda&lt;/script&gt;对应，&lt;script type=&quot;math/tex&quot;&gt;\nu&lt;/script&gt;要和&lt;script type=&quot;math/tex&quot;&gt;F_\nu&lt;/script&gt;对应。而SED的话，则是每个波长/频率上的&lt;strong&gt;能量&lt;/strong&gt;是多少，所以纵轴要相应地变为&lt;script type=&quot;math/tex&quot;&gt;\lambda F_\lambda&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;\nu F_\nu&lt;/script&gt;。取&lt;script type=&quot;math/tex&quot;&gt;\log{}&lt;/script&gt;之后可以把流量/能量比较低的部分的差异放大，但是单位就没有了。&lt;/p&gt;

&lt;h3 id=&quot;其他的校准和杂七杂八的东西&quot;&gt;其他的校准和杂七杂八的东西&lt;/h3&gt;

&lt;p&gt;谱线带来的吸收可以用模型或者高分辨率光谱来改正。有的时候为了确定一些物理量，我们会比较关注连续谱的斜率以及氢线系的线系限，但是光学的Balmer线系限除了有跳跃之外还有非常多的Balmer线，模糊了线系限左右的流量。所以有必要的话需要增加紫外/红外的观测。&lt;/p&gt;

&lt;p&gt;校准好之后将光谱和模型比较就可以得到恒星参数了。&lt;/p&gt;

&lt;h3 id=&quot;热星等&quot;&gt;热星等&lt;/h3&gt;

&lt;p&gt;略。&lt;/p&gt;
</description>
        <pubDate>Fri, 11 May 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/05/11/OASP10/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/11/OASP10/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>Deep Learning笔记3</title>
        <description>&lt;p&gt;这么多改进的方式，究竟要用哪个？&lt;/p&gt;

&lt;h2 id=&quot;正交化&quot;&gt;正交化&lt;/h2&gt;

&lt;p&gt;我们希望某个/些参数只影响某些结果。我们有训练样本、发展样本、测试样本、真实数据上的结果。最好就是存在某些参数可以分别改变网络在它们上的表现。&lt;/p&gt;

&lt;h3 id=&quot;single-number-evaluation-metric&quot;&gt;Single Number evaluation metric&lt;/h3&gt;

&lt;p&gt;找一个可以方便比较的数字。&lt;/p&gt;

&lt;p&gt;精确度和完整性：Harmonic average.&lt;/p&gt;

&lt;h3 id=&quot;复杂目标&quot;&gt;复杂目标&lt;/h3&gt;

&lt;p&gt;optimizing：数字越小/大越好；satisficing：够小就行了&lt;/p&gt;

&lt;p&gt;一般选一个作为optimizing，其他作为optimizing。&lt;/p&gt;

&lt;p&gt;而且实际上的模型好坏还包含别的东西，比如会不会推荐小黄片什么的。或者换一个模型或者评判的函数。&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/04/20/DL-3/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/20/DL-3/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>Deep Learning笔记2</title>
        <description>&lt;h4 id=&quot;数据集&quot;&gt;数据集&lt;/h4&gt;

&lt;p&gt;以前是分成两个的，训练和测试。现在分成3个，训练、发展和测试集。用发展去测试训练，最后再用测试去测试表现；甚至没有测试集都行。这里的区别是发展集是用来overfitting的，测试集不是。&lt;/p&gt;

&lt;p&gt;要注意不同数据集的数据要同质，质量相同&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;bias和variance&quot;&gt;bias和variance&lt;/h4&gt;

&lt;p&gt;训练集的错误率比与预期的高：高bias；发展集的错误率比训练集的高：高variance&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;正则化&quot;&gt;正则化&lt;/h4&gt;

&lt;p&gt;在代价函数后面加上&lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt;的2或者1范数&lt;/p&gt;

&lt;p&gt;通过强制减小&lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt;简化神经网络，减小权重。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dropout正则化&quot;&gt;Dropout正则化&lt;/h4&gt;

&lt;p&gt;随机删掉一些节点来做一次正反向传递，然后不断重复。要注意的是删掉之后要把整个节点的值除以一个删掉的阈值概率，把取值回覆到正常水平。测试集不要用。Dropoyt的意思是不让某个节点依赖于某几个前面一层的节点，所以也是减小权重的意思。不同的层可以有不同的dropout节点数。输入层一般不dropout（或者是很小的duopout数）。最后在看J减小的时候要小心一点，必要的时候关掉dropout&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;奇技淫巧&quot;&gt;奇技淫巧&lt;/h4&gt;

&lt;p&gt;增加训练样本：把图像翻过来/旋转/放大，或者几种加起来。不过信息量其实还是一样的。标准是人脑还是会把它当成同一样东西。&lt;/p&gt;

&lt;p&gt;提早停止：看发展集的误差，以它的最小值为基准。思路是&lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt;会随着迭代而不断增大，导致太大以至于我们不想看到。提早停止可以防止这个。&lt;/p&gt;

&lt;p&gt;正交化：将减小损失函数和防止overfit分开。提早停止违反了这个原则。&lt;/p&gt;

&lt;p&gt;L2正则化比较简单，不过要试各种的&lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;。&lt;/p&gt;

&lt;h3 id=&quot;建立最优化问题&quot;&gt;建立最优化问题&lt;/h3&gt;

&lt;h4 id=&quot;归一化训练集&quot;&gt;归一化训练集&lt;/h4&gt;

&lt;p&gt;看图，把输入数字移到0左右，将标准差scale到1。注意训练集和测试集的移动和scale需要完全一样。&lt;/p&gt;

&lt;p&gt;这么做的理由：将代价函数搞得好看一点，简单一点，学习速率也能快一点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;奇怪的导数值&quot;&gt;奇怪的导数值&lt;/h4&gt;

&lt;p&gt;在训练很深的神经网络的时候，有的时候导数值可能会很大或者很小，比如矩阵遇到了指数增长/减小什么的。&lt;/p&gt;

&lt;p&gt;一个治标的办法是选择初始的权重。&lt;script type=&quot;math/tex&quot;&gt;z = w_1x_1 + w_2x_2 + \cdots + w_nx_n&lt;/script&gt;。&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;越大，&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;就越大，所以我们控制&lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt;的标准差为&lt;script type=&quot;math/tex&quot;&gt;\sqrt{\frac{2}{n^{[l-1]}}}&lt;/script&gt;。这里的2是Relu函数带来的。当然也可以当它是一个超参数来试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;导数值检查&quot;&gt;导数值检查&lt;/h4&gt;

&lt;p&gt;往左和往右挪，计算&lt;script type=&quot;math/tex&quot;&gt;\frac{y}{x}&lt;/script&gt;。愣算就行。&lt;/p&gt;

&lt;p&gt;具体：将所有的参数竖着排成一个巨长的向量，包括正向的和反向的。然后愣算其中某个参数的导数，看两个向量之间的二范数比各自的二范数的大小。比值是拿来看相对大小的，防止它们本来就很小或者大。&lt;/p&gt;

&lt;p&gt;检查只能用在debug上。如果出错了，看具体的值哪个不正常。如果有的话，记得加上正则化项。检查不能用在dropout上，要用的话先关掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-2/1-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;加速&quot;&gt;加速&lt;/h3&gt;

&lt;h4 id=&quot;切成小块&quot;&gt;切成小块&lt;/h4&gt;

&lt;p&gt;每次只处理1000个训练样本，然后循环。基本上都得用。计算1000个之后就马上更新参数。当然也可以见到1个，不过随机性就很强；这也被叫做随机梯度下降。随机梯度下降相当于没有向量化，所以很慢，而且很多噪音。&lt;/p&gt;

&lt;p&gt;但是怎么选小块的大小？当整体训练样本小的时候，当然应该整个一起搞；如果大的话，可以用2的某次方来做（可能快一点），或者和CPU/GPU匹配的大小。试呗。&lt;/p&gt;

&lt;h4 id=&quot;不用梯度下降&quot;&gt;不用梯度下降&lt;/h4&gt;

&lt;h5 id=&quot;指数平均&quot;&gt;指数平均&lt;/h5&gt;
&lt;p&gt;其实就是滑动平均的一种，只不过前后的数据不平权。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v_t = \beta v_{t-1} + (1-\beta)\theta_t&lt;/script&gt;

&lt;p&gt;它会将之前的数据累积起来，但是不断乘上&lt;script type=&quot;math/tex&quot;&gt;\beta&lt;/script&gt;。大概相当于前&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{1-\beta}&lt;/script&gt;天的温度平均：&lt;script type=&quot;math/tex&quot;&gt;v_t = \sum_{i=0}^n 0.1 \times 0.9^i \theta_i&lt;/script&gt;。&lt;/p&gt;

&lt;h5 id=&quot;bias-correction&quot;&gt;Bias Correction&lt;/h5&gt;

&lt;p&gt;更准确的计算。因为上式从0开始，所以一开始的时候肯定是不对的。当然一般数据量大的话可以不管，反正可以等。或者除一个&lt;script type=&quot;math/tex&quot;&gt;(1-\beta^t)&lt;/script&gt;。&lt;/p&gt;

&lt;h5 id=&quot;gradient-descent-with-momentum&quot;&gt;Gradient descent with momentum&lt;/h5&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
 v_{dW} &amp;= \beta v_{dW} + (1-\beta) dW \\
 v_{db} &amp;= \beta v_{db} + (1-\beta) db \\
 W &amp;= W - \alpha v_{dW} \\
 b &amp;= b - \alpha v_{db} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;这样做的好处是它会在摆动的方向将摆动平均掉，在正确的方向保留导数值，所以可以加速收敛。一般&lt;script type=&quot;math/tex&quot;&gt;\beta = 0.9&lt;/script&gt;是个不错的选择。&lt;/p&gt;

&lt;h5 id=&quot;rmsprop&quot;&gt;RMSprop&lt;/h5&gt;

&lt;p&gt;另一种方式的加速。看图。&lt;/p&gt;

&lt;h5 id=&quot;adam&quot;&gt;Adam&lt;/h5&gt;

&lt;p&gt;合在一起。看图。&lt;/p&gt;

&lt;h4 id=&quot;降低学习速率&quot;&gt;降低学习速率&lt;/h4&gt;

&lt;p&gt;可以手动降低，乘上一个线性增大的分母，或者是e指数减小&lt;/p&gt;

&lt;h3 id=&quot;避免局部极小&quot;&gt;避免局部极小&lt;/h3&gt;

&lt;p&gt;很多导数为0的点实际上是鞍点，因为参数非常多。不过在那附近会转悠好久，比较慢。&lt;/p&gt;

&lt;h2 id=&quot;调超参&quot;&gt;调超参&lt;/h2&gt;

&lt;h3 id=&quot;要调的东西&quot;&gt;要调的东西&lt;/h3&gt;

&lt;p&gt;学习速率&lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;；动量项&lt;script type=&quot;math/tex&quot;&gt;\beta / (\beta_1=0.9, \beta_2=0.999, \epsilon=10^{-8})&lt;/script&gt;、多少节点、mini-batch大小；多少隐层、学习速率变化。&lt;/p&gt;

&lt;p&gt;但是调超参的时候不要用网格，随即就好；因为超参数量太多了，而且不同的超参对模型影响不同，所以随机会给所有的超参更多选择。最初的参数空间可能比较大，都跑一次之后可以缩小参数空间再做一次。随机的时候，对于某些超参，也可以不用平均随机，而是用其他的概率分布，或者log scale，量级上平均就行。或者说在模型对超参变化更剧烈的时候放更多的点。&lt;/p&gt;

&lt;h3 id=&quot;训练中&quot;&gt;训练中&lt;/h3&gt;

&lt;p&gt;训练中可以不断调整超参什么的。或者同时训练很多个模型，有钱有资源的话。&lt;/p&gt;

&lt;h3 id=&quot;让模型更稳健&quot;&gt;让模型更稳健&lt;/h3&gt;

&lt;p&gt;逻辑回归的时候将输入归一化可以让代价函数更规则，那么在神经网络里面也可以这么做，对&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;归一化。可以将&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;的平均值和标准差倒过来，或者自己设定一组数，或者让网络自己学习去。&lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;也可以不要了，因为归一化的时候带上了常数。&lt;/p&gt;

&lt;p&gt;其他具体流程和普通的差不多。它防止了隐层的值的分布距离原点太远。它会带来一些噪声。&lt;/p&gt;

&lt;p&gt;在测试集的时候，我们可以用指数平均的方法记录训练集的平均值和scatter，然后当成测试集的均值以及&lt;script type=&quot;math/tex&quot;&gt;\sigma&lt;/script&gt;。&lt;/p&gt;

&lt;h2 id=&quot;多项选择题&quot;&gt;多项选择题&lt;/h2&gt;

&lt;p&gt;Softmax回归。在最后一层隐层的地方将节点数和分类数相等，让每一个节点表示属于每一类的概率。sigmod函数会变成softmax函数，对这节点的值进行e指数，归一化。因为e指数会将值之间的差异扩大，所以可以进行分类。如果只有两类的话，softmax会退化回逻辑回归。&lt;/p&gt;

&lt;p&gt;损失函数：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(y, \hat{y}) = -\sum y_j \ln{\hat{y_j}}&lt;/script&gt;

&lt;p&gt;只留下正确的那一项，然后最大化它的概率。&lt;/p&gt;

&lt;p&gt;代价函数：还是损失函数的平均。&lt;/p&gt;

&lt;p&gt;反向传递：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;dz^{[l]} = \hat{y} - y&lt;/script&gt;

&lt;p&gt;但是在用框架的时候，只要正向传递对了，反向传递交给框架就行。&lt;/p&gt;

&lt;h2 id=&quot;机器学习框架&quot;&gt;机器学习框架&lt;/h2&gt;

&lt;p&gt;易用、快速、开源（特别是长期开源）&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Mar 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/03/14/DL-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/14/DL-2/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>Deep Learning笔记1</title>
        <description>&lt;h3 id=&quot;逻辑回归&quot;&gt;逻辑回归&lt;/h3&gt;

&lt;h4 id=&quot;binary-classification&quot;&gt;Binary Classification&lt;/h4&gt;

&lt;p&gt;Binary Classification指的是输入一堆东西，最后给出一个只有两个结果（0或者1）的输出的分类过程。一个典型而符合惯例的例子是判断某张图片上有没有猫，也就是将图片的红绿蓝像素值矩阵作为输入，是猫(1)以及不是猫(0)作为输出。&lt;/p&gt;

&lt;p&gt;在这里我们不考虑这么多细节，直接将红绿蓝的像素排成一列，作为输入&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;。&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;的大小就是总的像素数&lt;script type=&quot;math/tex&quot;&gt;n_x&lt;/script&gt;或者&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果按照位置来排呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/1-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要在开始之前明确一些记号。&lt;/p&gt;

&lt;p&gt;我们在寻找解的时候的输入为&lt;script type=&quot;math/tex&quot;&gt;(x, y)&lt;/script&gt;，当然就是&lt;script type=&quot;math/tex&quot;&gt;(图片, 是否猫)&lt;/script&gt;的组合了。其中&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;是一个&lt;script type=&quot;math/tex&quot;&gt;n_x&lt;/script&gt;行的&lt;strong&gt;列向量&lt;/strong&gt;，即&lt;script type=&quot;math/tex&quot;&gt;x \in \mathbb{R}^{n_x}&lt;/script&gt;；而&lt;script type=&quot;math/tex&quot;&gt;y \in \{0, 1\}&lt;/script&gt;。当然这只是一个样本，而我们一般会有很多的&lt;strong&gt;训练样本&lt;/strong&gt;(training set)：&lt;script type=&quot;math/tex&quot;&gt;\{ (x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), ..., (x^{(m)}, y^{(m)}) \}&lt;/script&gt;。&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;即为训练样本的数量；当我们需要明确的时候我们会把训练样本数和&lt;strong&gt;检验样本&lt;/strong&gt;(test set)数写成&lt;script type=&quot;math/tex&quot;&gt;m_\mathrm{train}, m_\mathrm{test}&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;这么写当然比较麻烦，所以我们有矩阵写法。首先将所有的&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;排成一行，就成了一个&lt;script type=&quot;math/tex&quot;&gt;n_x&lt;/script&gt;行&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;列的矩阵&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{X}&lt;/script&gt;。数学语言表达就是&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{X} \in \mathbb{R}^{n_x\times m}&lt;/script&gt;，python表达就是&lt;code class=&quot;highlighter-rouge&quot;&gt;X.shape = (nx, m)&lt;/code&gt;。把&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{X}&lt;/script&gt;转置也不是不行，不过会比较麻烦，就不用了。&lt;/p&gt;

&lt;p&gt;相应的所有的label也这么排，就成了一个一行&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;列的“矩阵”&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{Y} = [y^{(1)}, y^{(2)}, ..., y^{(m)}]&lt;/script&gt;；或者说&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{Y} \in \mathbb{R}^{1\times m}&lt;/script&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Y.shape = (1, m)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;更多的记号可参阅课程给的pdf。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/1-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;逻辑回归-1&quot;&gt;逻辑回归&lt;/h4&gt;

&lt;p&gt;实际上逻辑回归是在二项分布之下的一个概念，是实现二项分布的一个方法。我们需要的是在上面的定义下，构造一个盒子，接收输入&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, 并输出在输入&lt;script type=&quot;math/tex&quot;&gt;\mathbf{x}&lt;/script&gt;的情况下二项分布结果为1的概率&lt;script type=&quot;math/tex&quot;&gt;\hat{y} = P(y=1 \lvert \boldsymbol{x})&lt;/script&gt;。然后我们有相应的参数&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{w} \in \mathbb{R}^{n_x}, b \in \mathbb{R}&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;构造输出&lt;script type=&quot;math/tex&quot;&gt;\hat{y}&lt;/script&gt;的第一反应应该是&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{y} = \boldsymbol{w}^\mathrm{T} \boldsymbol{x} + b&lt;/script&gt;

&lt;p&gt;这其实就是普通的线性回归。但是我们要求&lt;script type=&quot;math/tex&quot;&gt;\hat{y}&lt;/script&gt;是一个概率，取值在0到1之间，而线性回归不仅不能保证结果小于1还会出现负的结果，当然是不对的。&lt;/p&gt;

&lt;p&gt;那怎么办？很简单，给线性回归的结果套一个值域在0到1之间的函数不就行了呗。这种函数一般都跟&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;指数有关，所以我们有sigmod函数：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sigma(z) = \frac{1}{1+e^{-z}}&lt;/script&gt;

&lt;p&gt;图像请看截图的左下角。&lt;/p&gt;

&lt;p&gt;有了sigmod函数之后，只要令&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{y} = \sigma(\boldsymbol{w}^\mathrm{T} \boldsymbol{x} + b)&lt;/script&gt;

&lt;p&gt;就行了。加上了sigmod函数之后的回归就叫逻辑回归。有的方法把&lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;也放进&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{w}&lt;/script&gt;里面，不过这里不这么做。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/1-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代价损失函数&quot;&gt;代价/损失函数&lt;/h4&gt;

&lt;p&gt;代价/损失函数就是用来训练上面提到的&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{w}, b&lt;/script&gt;的。这个函数越小，模型的效果越好（对于训练样本来说）。这里定义的损失函数只是对于一个训练样本来说的，而代价函数是对于整个训练样本集在某一堆参数下的评价。&lt;/p&gt;

&lt;p&gt;学过线性拟合的同学们马上又该反应过来，一个典型的代价函数就是&lt;script type=&quot;math/tex&quot;&gt;L(\hat{y}, y) = (\hat{y} - y)^2&lt;/script&gt;。但是这个函数的效果并不好，所以我们实际上用的是这个：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(\hat{y}, y) = -[y \ln{\hat{y}} + (1-y) \ln{(1-\hat{y})}]&lt;/script&gt;

&lt;p&gt;大致地说为什么代价函数的样子是这样的原因是，差值的平方会导致函数非凸，但是上面的定义加上sigmod函数会使得&lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt;是个凸函数，没有局部极值。&lt;/p&gt;

&lt;p&gt;对应的代价函数我们选择这个：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
J(\boldsymbol{w}, b) &amp;= \frac{1}{m} \sum_{i=1}^{m} L(\hat{y}^{(i)}, y^{(i)}) \\
 &amp;= - \frac{1}{m} \sum_{i=1}^{m} [y \ln{\hat{y}} + (1-y) \ln{(1-\hat{y})}]
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;只要找到最小化&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{w}, b&lt;/script&gt;的&lt;script type=&quot;math/tex&quot;&gt;J&lt;/script&gt;，就行了。实际上逻辑回归就是一个小型的（可能还是最简单的）神经网络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/1-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;如何训练参数&quot;&gt;如何训练参数？&lt;/h4&gt;

&lt;p&gt;最小化&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{w}, b&lt;/script&gt;就是在&lt;script type=&quot;math/tex&quot;&gt;J(\boldsymbol{w}, b)&lt;/script&gt;这个表面上（简单来说）迭代地找到这个函数的最小值以及对应的参数。又该反应过来我们需要用到导数来指导我们向哪里走了。具体来说，是计算这个：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\boldsymbol{w} &amp;:= \boldsymbol{w} - \alpha \frac{\partial J}{\partial \boldsymbol{w}}\\
b &amp;:= b - \alpha \frac{\partial J}{\partial b}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;被称为学习速率，是人选的；而后面的俩偏导数是需要计算的，在python中会被命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;dw, db&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/1-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;正反向传递&quot;&gt;正反向传递&lt;/h4&gt;

&lt;p&gt;具体请看截图。正向传递的意思是从具体参数计算代价函数值的过程（蓝色、从左到右），而反向传递指的是计算导数的过程（红色、从右到左）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/1-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;导数的具体计算&quot;&gt;导数的具体计算&lt;/h4&gt;

&lt;p&gt;我们举一个简单的例子：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
z &amp;= w_1 x_1 + w_2 x_2 + b \\
\hat{y} &amp;= \sigma(z) \\
L(\hat{y}, y) &amp;= -[y \ln{\hat{y}} + (1-y) \ln{(1-\hat{y})}] \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;自然地&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\frac{dL}{d\hat{y}} &amp;= -\frac{y}{\hat{y}} + \frac{1-y}{1-\hat{y}} \\
\frac{d\hat{y}}{dz} &amp;= \hat{y} (1-\hat{y}) = \sigma (1-\sigma) = \hat{y} - y \\
\frac{dz}{dw_1} &amp;= x_1 \frac{d\hat{y}}{dz} \\
\frac{dz}{dw_2} &amp;= x_2 \frac{d\hat{y}}{dz} \\
\frac{dz}{db} &amp;= \frac{d\hat{y}}{dz} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;在代码中我们基本上会用导数的分母作为变量名字。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/1-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后我们需要算的就是代价函数了。其实也没什么，就拿一个变量做代表吧：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial J}{\partial w_1} = \frac{1}{m} \sum_{i=1}^{m} \frac{L^{(i)}}{\partial w_1}&lt;/script&gt;

&lt;p&gt;具体的计算过程就是一个正向+反向传递的过程：&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 设置初值&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dw1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# Forward propagation&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;J&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# Backward propagation&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dw1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;J&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dw1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dw1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后继续迭代。所以“正常”情况下要用两个循环嵌套，显然是不现实的，所以要用到python的向量来做。&lt;/p&gt;

&lt;h4 id=&quot;向量化&quot;&gt;向量化&lt;/h4&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;是一个列向量的时候，比如要算&lt;code class=&quot;highlighter-rouge&quot;&gt;z[i] = w.T * x[i] + b&lt;/code&gt;的时候，可以这么做：&lt;code class=&quot;highlighter-rouge&quot;&gt;np.dot(w,x)+b&lt;/code&gt;。高级一点的话直接和矩阵相乘：&lt;code class=&quot;highlighter-rouge&quot;&gt;np.dot(w,X)+b&lt;/code&gt;。
&lt;code class=&quot;highlighter-rouge&quot;&gt;dz[i] = a[i] - y[i]&lt;/code&gt;可以转为&lt;code class=&quot;highlighter-rouge&quot;&gt;dZ = A - Y&lt;/code&gt;；&lt;code class=&quot;highlighter-rouge&quot;&gt;dw1 += x1[i]dz[i]&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;dW = 1/m * X*dZ.T&lt;/code&gt;；&lt;code class=&quot;highlighter-rouge&quot;&gt;db += dz[i]&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;1/m * np.sum(dZ)&lt;/code&gt;。还要注意的一点是在&lt;code class=&quot;highlighter-rouge&quot;&gt;reshape&lt;/code&gt;的时候最好把行列都写全。&lt;/p&gt;

&lt;h3 id=&quot;浅神经网络&quot;&gt;浅神经网络&lt;/h3&gt;

&lt;p&gt;[1],[2]代表神经网络的层数；(i)代表某一个训练样本（都是上标）。下标不带任何括号，表示某一层中的第几个节点。当有两层的时候，刚开始的输入是&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;，但是之后的输入会变成了&lt;script type=&quot;math/tex&quot;&gt;a^{[i]}&lt;/script&gt;这样。&lt;/p&gt;

&lt;h4 id=&quot;神经网络的命名&quot;&gt;神经网络的命名&lt;/h4&gt;

&lt;p&gt;输入层、隐层、输出层。&lt;script type=&quot;math/tex&quot;&gt;a^{[0]} = x&lt;/script&gt;。在数层数的时候，不算输入层。每一层都有一套&lt;script type=&quot;math/tex&quot;&gt;w, b&lt;/script&gt;配套。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个节点都有两步：线性回归以及丢进sigmod函数里面。所以都有两条公式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
  z_1^{[1]} &amp;= w_1^{[1]T}x + b_1^{[1]}, a_1^{[1]} = \sigma(z_1^{[1]}) \\
  z_2^{[1]} &amp;= w_2^{[1]T}x + b_2^{[1]}, a_2^{[1]} = \sigma(z_2^{[1]}) \\
  z_3^{[1]} &amp;= w_3^{[1]T}x + b_3^{[1]}, a_3^{[1]} = \sigma(z_3^{[1]}) \\
  z_4^{[1]} &amp;= w_4^{[1]T}x + b_4^{[1]}, a_4^{[1]} = \sigma(z_4^{[1]}) \\
  \vdots
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;能看到这些式子排得很整齐，那何不矩阵化了呢？&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z^{[1]} =
  \begin{bmatrix}
    z_1^{[1]} \\ z_2^{[1]} \\ z_3^{[1]} \\ z_4^{[1]}
  \end{bmatrix}
  =
  \begin{bmatrix}
    \cdots w_1^{[1]T} \cdots \\ \cdots w_2^{[1]T} \cdots \\ \cdots w_3^{[1]T} \cdots \\ \cdots w_4^{[1]T} \cdots
  \end{bmatrix}
  \begin{bmatrix}
    x_1 \\ x_2 \\ x_3
  \end{bmatrix}
  +
  \begin{bmatrix}
    b_1^{[1]} \\ b_2^{[1]} \\ b_3^{[1]} \\ b_4^{[1]}
  \end{bmatrix}
  = W^{[1]} x + b^{[1]}&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;W^{[i]}&lt;/script&gt;是一个&lt;script type=&quot;math/tex&quot;&gt;n^{[i]}&lt;/script&gt;（本层节点数）行&lt;script type=&quot;math/tex&quot;&gt;n^{[i-1]}&lt;/script&gt;（上层节点数）列的矩阵，也就是负责将上层节点的结果转成本层节点的结果。&lt;script type=&quot;math/tex&quot;&gt;b^{[i]}&lt;/script&gt;自然是&lt;script type=&quot;math/tex&quot;&gt;n^{[i]}&lt;/script&gt;行1列的向量了。最后再将结果各自丢进sigmod函数里面，不说了。&lt;/p&gt;

&lt;p&gt;如果写出个通式的话也行：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
   z^{[i]} &amp;=  W^{[i]} a^{[i-1]} + b^{[i]} \\
   a^{[i]} &amp;= \sigma(z^{[i]})
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;不过注意&lt;script type=&quot;math/tex&quot;&gt;a^{[0]}&lt;/script&gt;就是输入值，没有放入sigmod函数里面。同时矩阵&lt;script type=&quot;math/tex&quot;&gt;W^{[i]}&lt;/script&gt;是一个“行矩阵”，每一行是每一个节点的系数的转置&lt;script type=&quot;math/tex&quot;&gt;[\cdots w_i^{[1]T} \cdots]&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;对于整个训练样本&quot;&gt;对于整个训练样本&lt;/h4&gt;

&lt;p&gt;当然可以继续矩阵化啦。把整个训练样本的列向量&lt;script type=&quot;math/tex&quot;&gt;x,b&lt;/script&gt;排成一行（这也是惟一的排法了），结果&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;也这么做，然后大写，就变成了：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
Z^{[1]} &amp;=
  \begin{bmatrix}
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
    z^{[1](1)} &amp; z^{[1](2)} &amp; \cdots &amp; z^{[1](m)} \\
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
  \end{bmatrix}
  =
  \begin{bmatrix}
    \cdots w_1^{[1]T} \cdots \\ \cdots w_2^{[1]T} \cdots \\ \vdots \\ \cdots w_{[i]}^{[1]T} \cdots
  \end{bmatrix}
  \begin{bmatrix}
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
    x^{(1)} &amp; x^{(2)} &amp; \cdots &amp; x^{(m)} \\
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
  \end{bmatrix}
  +
  \begin{bmatrix}
    \vdots \\ b^{[1]} \\ \vdots \\
  \end{bmatrix} \\
  &amp;= W^{[1]} X + b^{[1]}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;或者对于某一层来说&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
Z^{[i]} &amp;=
  \begin{bmatrix}
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
    z^{[i](1)} &amp; z^{[i](2)} &amp; \cdots &amp; z^{[i](m)} \\
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
  \end{bmatrix}
  =
  \begin{bmatrix}
    \cdots w_1^{[i]T} \cdots \\ \cdots w_2^{[i]T} \cdots \\ \vdots \\ \cdots w_{[i]}^{[i]T} \cdots
  \end{bmatrix}
  \begin{bmatrix}
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
    a^{[i](1)} &amp; a^{[i](2)} &amp; \cdots &amp; a^{[i](m)} \\
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
  \end{bmatrix}
  +
  \begin{bmatrix}
    \vdots \\ b^{[i]} \\ \vdots \\
  \end{bmatrix} \\
  &amp;= W^{[i]} X + b^{[i]}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;总结一下，&lt;script type=&quot;math/tex&quot;&gt;Z^{[i]}&lt;/script&gt;是一个&lt;script type=&quot;math/tex&quot;&gt;n^{[i]}&lt;/script&gt;行&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;列的矩阵，&lt;script type=&quot;math/tex&quot;&gt;W^{[i]}&lt;/script&gt;是一个&lt;script type=&quot;math/tex&quot;&gt;n^{[i]}&lt;/script&gt;行&lt;script type=&quot;math/tex&quot;&gt;n^{[i-1]}&lt;/script&gt;列的矩阵，&lt;script type=&quot;math/tex&quot;&gt;A^{[i]}&lt;/script&gt;是一个&lt;script type=&quot;math/tex&quot;&gt;n^{[i]}&lt;/script&gt;行&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;列的矩阵，&lt;script type=&quot;math/tex&quot;&gt;b^{[i]}&lt;/script&gt;本来应该也是一个&lt;script type=&quot;math/tex&quot;&gt;[i]&lt;/script&gt;行&lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;列的矩阵（每列都是一样），但是在python里面，同行数的向量和矩阵相加时，向量会被自动展成相应的矩阵，所以也就不用写成大写的&lt;script type=&quot;math/tex&quot;&gt;B^{[i]}&lt;/script&gt;了。可以留意的是向量/矩阵的偏导数和它自己有相同的形状。&lt;/p&gt;

&lt;p&gt;通式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
   Z^{[i]} &amp;=  W^{[i]} A^{[i-1]} + b^{[i]} \\
   A^{[i]} &amp;= \sigma(Z^{[i]})
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;不同的activation-function&quot;&gt;不同的activation function&lt;/h4&gt;

&lt;p&gt;sigmod函数的问题是它恒为正，所以算出来的结果不会关于0对称。所以隐藏层一般用&lt;script type=&quot;math/tex&quot;&gt;\tanh(z)&lt;/script&gt;而不是sigmod，但是输出层还是用回sigmod。&lt;/p&gt;

&lt;p&gt;但是&lt;script type=&quot;math/tex&quot;&gt;\tanh(z)&lt;/script&gt;也还是有问题：当&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;很大的时候，斜率很小，所以会降低学习速率；所以也可以用RelU函数（折线），或者将RelU小于0的折线再改小一点。即使斜率为0实际上也还是可以的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;为什么activation-function不是线性的&quot;&gt;为什么activation function不是线性的？&lt;/h4&gt;

&lt;p&gt;也就是说为什么要给它套上一个奇怪的函数？&lt;/p&gt;

&lt;p&gt;线性的AF意味着从头到脚都是线性的，也就没有意义（人又不是线性思考的233）。例外是在回归里面，当输出不在0到1之间的时候，最后一层可以用线性的。但是其他层还是要用非线性的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;af的导数&quot;&gt;AF的导数&lt;/h4&gt;

&lt;p&gt;求就是了，又不是不会。按照链式反应（chain rule啦）来求就行了。按照之前的结论其实&lt;script type=&quot;math/tex&quot;&gt;\frac{dL}{da^{[2]}}&lt;/script&gt;不用求，有&lt;script type=&quot;math/tex&quot;&gt;\frac{dL}{dz^{[2]}} = a^{[2]} - y&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;完全向量化之后出现的&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{m}&lt;/script&gt;以及求和是因为之前对某一个训练样本来说，只能计算损失函数；但是对于整个训练样本集来说，我们计算的是代价函数，而&lt;script type=&quot;math/tex&quot;&gt;J = \frac{1}{m}\sum L&lt;/script&gt;，所以多了点东西。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;随机初值&quot;&gt;随机初值&lt;/h4&gt;

&lt;p&gt;参数全为0的话，所有的节点都是一样（对称）的，就没用了。所以要随机取值。一般会将&lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt;取为很小的高斯随机数，但是&lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;没所谓。很小的高斯随机数是为了取到比较大的导数值，防止落到导数很靠近0的地方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/2-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;深神经网络&quot;&gt;深神经网络&lt;/h3&gt;

&lt;p&gt;多层的神经网络和2层的其实是一样的，只不过多了一堆循环而已。&lt;/p&gt;

&lt;h4 id=&quot;为什么要用深的神经网络&quot;&gt;为什么要用深的神经网络？&lt;/h4&gt;

&lt;p&gt;层数从小到大：简单元素 -&amp;gt; 复杂元素。所以我们需要比较多层，但是每层里面的节点不一定多。&lt;/p&gt;

&lt;p&gt;比单层的好用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/3-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;正向传递&quot;&gt;正向传递&lt;/h4&gt;

&lt;p&gt;计算不同层数的时候可以用循环。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/3-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;反向传递&quot;&gt;反向传递&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/3-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;具体做法&quot;&gt;具体做法&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-DL-1/3-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为反向传递的时候有一个&lt;script type=&quot;math/tex&quot;&gt;g'^{[l]}(z^{[l]})&lt;/script&gt;，所以在正向传递的时候要将&lt;script type=&quot;math/tex&quot;&gt;z^{[l]}&lt;/script&gt;记录下来。&lt;/p&gt;

&lt;h4 id=&quot;参数和超参数&quot;&gt;参数和超参数&lt;/h4&gt;

&lt;p&gt;超参数：人为指定的参数&lt;/p&gt;

&lt;p&gt;看超参数和&lt;script type=&quot;math/tex&quot;&gt;J&lt;/script&gt;的关系（选多少的时候最小），是一个经验方法。最佳的超参数集可能会随着时间变化（电脑更新了）&lt;/p&gt;

&lt;p&gt;这次的笔记本还演示了如何载入另外一个笔记本的函数。&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Mar 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/03/14/DL-1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/14/DL-1/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>OASP笔记 - 9</title>
        <description>&lt;p&gt;乍看起来人为地制造一个恒星或者光球层的模型似乎没有必要。难道就不能从观测到的恒星光谱中导出我们想要的参数吗？就像从视差算出距离一样，只不过现在的公式或者方法比倒数麻烦很多而已。不过抱歉还真的不能，因为影响恒星光谱的因素实在太多，所以这样做一般是不现实的。所以要知道我们想知道的信息，我们只能倒过来，从一些理论和物理规律去造出一个模型，然后将模型产生的光谱和实际的光谱对比并不断修正，直到它们非常相像，我们才认为这个模型至少反映了一些实际，并用模型的参数去反映恒星的参数。&lt;/p&gt;

&lt;p&gt;我们在第七章看到计算光强或者流量的时候我们需要源函数，同时在第八章看到计算&lt;script type=&quot;math/tex&quot;&gt;\kappa&lt;/script&gt;的时候还需要压强（气体的和电子的）；所以光球层模型至少需要包括不同光深下面的源函数和压强（三列很多行的一个表），当然需要的话还可以在后面加上其他的参数。作为例子，这里给出一个Kurucz的模型（MOOG格式）：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;KURUCZ&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TEFF   4750.  GRAVITY 2.50000 LTE[0.0] VTURB=2  L/H=1.25 NOVER&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ntau=       72&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;\rho x&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;N_\mathrm{e}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;\kappa_\mathrm{ross}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2.48844185E-03&lt;/td&gt;
      &lt;td&gt;2877.3&lt;/td&gt;
      &lt;td&gt;7.869E-01&lt;/td&gt;
      &lt;td&gt;3.746E+07&lt;/td&gt;
      &lt;td&gt;5.359E-05&lt;/td&gt;
      &lt;td&gt;9.873E-03&lt;/td&gt;
      &lt;td&gt;2.000E+05&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3.29274059E-03&lt;/td&gt;
      &lt;td&gt;2900.6&lt;/td&gt;
      &lt;td&gt;1.041E+00&lt;/td&gt;
      &lt;td&gt;4.908E+07&lt;/td&gt;
      &lt;td&gt;5.701E-05&lt;/td&gt;
      &lt;td&gt;1.014E-02&lt;/td&gt;
      &lt;td&gt;2.000E+05&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4.29948870E-03&lt;/td&gt;
      &lt;td&gt;2923.9&lt;/td&gt;
      &lt;td&gt;1.360E+00&lt;/td&gt;
      &lt;td&gt;6.364E+07&lt;/td&gt;
      &lt;td&gt;6.082E-05&lt;/td&gt;
      &lt;td&gt;1.011E-02&lt;/td&gt;
      &lt;td&gt;2.000E+05&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;第一行是指名模型类型（MOOG也接受其他的一些模型），第二行是注释（有效温度和logg），第三行指名接下来的72行都是模型的内容。计算光谱的时候用到的物理量是光深、温度、气体压强、电子数密度或者是压强、Rossland不透明度。这里没有用到源函数的原因应该是认为热动平衡下每层的源函数都是普朗克函数，所以有温度就可以算出源函数了。所以有了模型之后就可以根据&lt;script type=&quot;math/tex&quot;&gt;(7.15)&lt;/script&gt;来算流量了。&lt;/p&gt;

&lt;p&gt;这本书的主旨是“读完某一章之后就可以拿这一章的内容来做计算”，所以这里提到的模型肯定有很多假设，距离真实情况有一定距离。但是这不代表着它们没有用，它们仍然是不错的工具和真实模型的起点。这里的假设和简化包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;平面平行层假设，所有物理量只和深度有关&lt;/li&gt;
  &lt;li&gt;处于流体静力学平衡，没有很大的膨胀和收缩，没有质量损失&lt;/li&gt;
  &lt;li&gt;忽略米粒组织和和黑子，或者把它们也包括在光球层的平均物理量里面&lt;/li&gt;
  &lt;li&gt;忽略磁场的影响&lt;/li&gt;
  &lt;li&gt;处于热动平衡，有&lt;script type=&quot;math/tex&quot;&gt;(1.18), (1.19)&lt;/script&gt;以及源函数为普朗克函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很明显想要改进模型的话放宽这些条件就行了。十七、十八章会放宽最后一个条件。热动平衡并不是全局的，只是在某一个（相对光球层）比较小的&lt;script type=&quot;math/tex&quot;&gt;dx&lt;/script&gt;里面成立，所以我们将光球层分成很多个子层，每一层有一个温度对应（上面的模型表格）；这就叫局部热动平衡(LTE)。&lt;/p&gt;

&lt;h3 id=&quot;流体静力学平衡&quot;&gt;流体静力学平衡&lt;/h3&gt;

&lt;p&gt;流体静力学平衡就意味着压强差等于体元的所受的重力：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;dP = dF/dA = \rho g dx&lt;/script&gt;

&lt;p&gt;这里的&lt;script type=&quot;math/tex&quot;&gt;dF,dx&lt;/script&gt;都是里面减外面；而我们用&lt;script type=&quot;math/tex&quot;&gt;dx&lt;/script&gt;定义的光深刚好也是这个方向的，所以：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{dP}{d\tau_\nu} = \frac{g}{\kappa_\nu} \tag{9.1}&lt;/script&gt;

&lt;p&gt;这里的压强是总的压强。一般来说这里面气体压强占大头，除了一些特殊情况：高温恒星的辐射压&lt;script type=&quot;math/tex&quot;&gt;(5.11)&lt;/script&gt;、磁场的压强或者湍流的压强。所以我们又欢乐地将总压强替换成气体压强&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}&lt;/script&gt;了。&lt;/p&gt;

&lt;p&gt;对&lt;script type=&quot;math/tex&quot;&gt;(9.1)&lt;/script&gt;两边都乘一个&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}^{1/2}&lt;/script&gt;，然后为了方便起见将某波长上的光深&lt;script type=&quot;math/tex&quot;&gt;\kappa_\nu&lt;/script&gt;换成参考波长5000Å上的光深&lt;script type=&quot;math/tex&quot;&gt;\kappa_0&lt;/script&gt;，得：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{g}^{1/2} dP_\mathrm{g} = P_\mathrm{g}^{1/2}\frac{g}{\kappa_0} d\tau_0&lt;/script&gt;

&lt;p&gt;要多说两句的是以后下标带&lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;的量都指的是在参考波长上的量；在后面会看到&lt;script type=&quot;math/tex&quot;&gt;\tau_0&lt;/script&gt;可以转换成其他波长上的光深，并且因为不同波长上的同一个光深值一般代表着不同的几何深度，在比较不同波长上的量的时候转换到同一个光深尺度下面是有必要的。&lt;/p&gt;

&lt;p&gt;将上式两边积分，得：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align} P_\mathrm{g}(\tau_0) &amp;= ( \frac{3}{2} g \int_0^{\tau_0} \frac{P_\mathrm{g}^{1/2}}{\kappa_0} dt_0 )^{2/3} \\ &amp;= ( \frac{3}{2} g \int_{-\infty}^{\log{\tau_0}} \frac{t_0^{1/2}P_\mathrm{g}^{1/2}}{\kappa_0 \log{e}} d\log{t_0} )^{2/3} \end{align} \tag{9.2} %]]&gt;&lt;/script&gt;

&lt;p&gt;换成&lt;script type=&quot;math/tex&quot;&gt;\log{}&lt;/script&gt;是因为这样能有更高的精度。这是个超越方程所以我们先猜一个&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}(\tau_0)&lt;/script&gt;，代进去算出新的&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}(\tau_0)&lt;/script&gt;之后再重复直到收敛。即使我们猜了&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}(\tau_0)&lt;/script&gt;，上面的式子里仍有吸收系数&lt;script type=&quot;math/tex&quot;&gt;\kappa_0&lt;/script&gt;是未知的，所以我们先要知道&lt;script type=&quot;math/tex&quot;&gt;\kappa_0&lt;/script&gt;。这就是第八章干的活，而从那里的结论我们知道&lt;script type=&quot;math/tex&quot;&gt;\kappa_0&lt;/script&gt;是温度和电子压强的函数，然后我们就要去求&lt;script type=&quot;math/tex&quot;&gt;T(\tau_0), P_\mathrm{e}(\tau_0)&lt;/script&gt;了。&lt;/p&gt;

&lt;h3 id=&quot;恒星光球层的温度&quot;&gt;恒星光球层的温度&lt;/h3&gt;

&lt;h5 id=&quot;太阳&quot;&gt;太阳&lt;/h5&gt;

&lt;p&gt;我们有两个方法获取恒星光球层的温度：临边昏暗以及吸收系数在不同波长上的变化。&lt;/p&gt;

&lt;p&gt;很明显临边昏暗只能用在太阳身上。&lt;script type=&quot;math/tex&quot;&gt;(7.10)&lt;/script&gt;给出：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I_\nu(0) = \int_{0}^\infty S_\nu e^{-t_\nu\sec{\theta}}\sec{\theta} dt_\nu \tag{9.3}&lt;/script&gt;

&lt;p&gt;也就是说太阳表面的辐射强度是受&lt;script type=&quot;math/tex&quot;&gt;e^{-t_\nu\sec{\theta}}&lt;/script&gt;调节的。辐射强度主要的贡献来自于&lt;script type=&quot;math/tex&quot;&gt;S_\nu\sec{\theta} \sim \frac{1}{e} S_\nu\sec{\theta}&lt;/script&gt;的这个范围内，而随着我们的视线方向逐渐远离太阳中心，达到&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{e} S_\nu\sec{\theta}&lt;/script&gt;所需的光深越来越小，也就是我们能看到的表面越来越浅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/Limb_darkening.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;太阳的临边昏暗&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在灰大气模型下，&lt;script type=&quot;math/tex&quot;&gt;(7.34)&lt;/script&gt;可以写成：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;S_\nu = a + b\tau_\nu&lt;/script&gt;

&lt;p&gt;代进&lt;script type=&quot;math/tex&quot;&gt;(9.3)&lt;/script&gt;里面可以得到：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I_\nu(0) = a + b \cos{\theta}&lt;/script&gt;

&lt;p&gt;也就是说在&lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt;角观测到的辐射强度就是在光深&lt;script type=&quot;math/tex&quot;&gt;\tau_\nu&lt;/script&gt;处的源函数的值，所以只要观测辐射强度我们就知道了源函数；这叫做Eddington-Barbier关系。当然更复杂一点的源函数也可以通过数值模拟来找到。&lt;/p&gt;

&lt;p&gt;一个稍微定量一点的方法是将&lt;script type=&quot;math/tex&quot;&gt;(9.3)&lt;/script&gt;写成对数坐标下的形式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I_\nu(0) = \int_{-\infty}^\infty S_\nu e^{-t_\nu\sec{\theta}}t_\nu\sec{\theta} \frac{d\log{t_\nu}}{\log{e}} \tag{9.4}&lt;/script&gt;

&lt;p&gt;右边的积分叫做贡献函数，它反映了每层的辐射对表面光强的贡献。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.3.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;不同角度位置上的贡献函数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如上图，右边为大气底部，左边为大气顶端（对于光深来讲）。我们可以看到没有光从很顶端以及底部的区域发射出来，同时越靠近恒星边缘我们主要看见的光就越从光深更小的地方发射。这里的源函数取得非常随意，只是保证了普朗克函数的形式(&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{e^{0.001/\tau}-1}&lt;/script&gt;)，所以&lt;script type=&quot;math/tex&quot;&gt;dI_\nu&lt;/script&gt;的值和书上的有较大差异。同样实际操作中我们也是把顺序倒过来，通过观测到的&lt;script type=&quot;math/tex&quot;&gt;I_\nu&lt;/script&gt;计算出源函数。&lt;/p&gt;

&lt;p&gt;第二个办法是在不同波段上观测。除了角度之外，吸收系数&lt;script type=&quot;math/tex&quot;&gt;\kappa_\nu&lt;/script&gt;也会决定我们能看得多深，所以对于中低温恒星来说在16000Å左右我们能看得最深，；往短波方向走我们看得越来越浅因为负氢离子的吸收变大（第八章的gif图）；波长小于2500Å之后虽然负氢离子的吸收变小了但是金属的吸收变大了。当然能结合临边昏暗以及不同波长能给我们带来最多的信息。其他还有的办法是观测强的谱线，将在第十三章详述。&lt;/p&gt;

&lt;p&gt;所以对于太阳来说，结果大致是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://wwwuser.oats.inaf.it/castelli/sun.html&quot;&gt;Kurucz模型&lt;/a&gt;
&lt;a href=&quot;http://marcs.astro.uu.se/index.php&quot;&gt;MARCS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本上在&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
-3 &lt; \log{\tau_0} &lt; 1 %]]&gt;&lt;/script&gt;的范围内所有模型都一致，因为有观测数据支撑；更深的地方模型们开始有分歧，因为处理对流的方式不一样。而在光深很小的地方的分歧部分原因是LTE不再成立。&lt;/p&gt;

&lt;p&gt;另一个必须要提及的点是实际上同一层内温度肯定不会处处相同；温度起伏在百分之几到25%左右，这也是模型没有顾及的。&lt;/p&gt;

&lt;h5 id=&quot;其他恒星&quot;&gt;其他恒星&lt;/h5&gt;

&lt;p&gt;显然我们不能用临边昏暗去得到其他恒星的温度（边看都看不见还昏什么暗）。所以我们一是完全从理论计算，或者直接将太阳的模型变换到别的恒星上。&lt;/p&gt;

&lt;p&gt;理论计算来源于&lt;script type=&quot;math/tex&quot;&gt;(7.14)&lt;/script&gt;。当然还要加上&lt;script type=&quot;math/tex&quot;&gt;(7.22), (7.28), (7.30)&lt;/script&gt;和流量守恒（恒星大气不发光）。先猜一个源函数，代进&lt;script type=&quot;math/tex&quot;&gt;(7.14)&lt;/script&gt;算出流量，再根据流量守恒去修改源函数直到收敛。具体例子可以看P179中间提到的论文。有的时候我们还要加上谱线的影响，称之为line blanketing。&lt;/p&gt;

&lt;p&gt;理论计算主要的误差来源与不准确的&lt;script type=&quot;math/tex&quot;&gt;\kappa_\nu&lt;/script&gt;以及对对流的处理（混合长的选择什么的）。对流并不会对表面流量产生很大的影响，但是会改变底层的温度。我们会在第十七章引入对流。&lt;/p&gt;

&lt;p&gt;恒星大气的理论模型十分复杂，所以多数的研究都会把模型算好并发布，直接拿来用就行了。&lt;/p&gt;

&lt;p&gt;将太阳的模型变换到别的恒星上虽然看起来比较粗暴但是还是有一些理由的。它的做法是用一个常数去乘太阳的温度，得到恒星的温度：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T(\tau_0) = S_0 T_\odot(\tau_0)&lt;/script&gt;

&lt;p&gt;灰大气模型下面这么做是完全没有问题的，因为&lt;script type=&quot;math/tex&quot;&gt;(7.36)&lt;/script&gt;：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T(\tau) = [\frac{3}{4}(\tau+\frac{2}{3})]^{1/4} T_\mathrm{eff}&lt;/script&gt;

&lt;p&gt;可得&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T(\tau) = \frac{T_\mathrm{eff}}{T_\mathrm{eff}^\odot}T_\odot(\tau)&lt;/script&gt;

&lt;p&gt;这两种方法的结果是差不多的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然巨星和矮星会有不同，可能需要一个标准巨星。&lt;/p&gt;

&lt;p&gt;实际操作中也可以直接拿格点中的恒星模型来稍作变换然后得到想要的模型，因为常数&lt;script type=&quot;math/tex&quot;&gt;S_0&lt;/script&gt;可以随便取。&lt;/p&gt;

&lt;p&gt;到此我们就认为我们已经知道恒星大气每层的温度了。下一个要知道的是气体压强。&lt;/p&gt;

&lt;h3 id=&quot;气体压强-电子压强-温度关系&quot;&gt;气体压强-电子压强-温度关系&lt;/h3&gt;

&lt;p&gt;当我们在解&lt;script type=&quot;math/tex&quot;&gt;(9.2)&lt;/script&gt;的时候我们先猜一个气体压强&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}&lt;/script&gt;。之后我们就需要算&lt;script type=&quot;math/tex&quot;&gt;\kappa_0&lt;/script&gt;，所以我们马上就要求出电子压强&lt;script type=&quot;math/tex&quot;&gt;p_\mathrm{e}&lt;/script&gt;和气体压强的关系。令单位体积内某种元素&lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt;的一次电离离子的数量为&lt;script type=&quot;math/tex&quot;&gt;N_{1j}&lt;/script&gt;，原子数量为&lt;script type=&quot;math/tex&quot;&gt;N_{0j}&lt;/script&gt;，则根据&lt;script type=&quot;math/tex&quot;&gt;(1.20)&lt;/script&gt;有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{N_{1j}}{N_{0j}} = \frac{\Phi_j(T)}{P_\mathrm{e}}&lt;/script&gt;

&lt;p&gt;忽略二次及以上的电离，&lt;script type=&quot;math/tex&quot;&gt;N_{1j}&lt;/script&gt;就和&lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt;元素贡献的电子的数量&lt;script type=&quot;math/tex&quot;&gt;N_{ej}&lt;/script&gt;相同，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\Phi_j(T)}{P_\mathrm{e}} = \frac{N_{ej}}{N_{0j}} = \frac{N_{ej}}{N_{j} - N_{ej}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Rightarrow N_{\mathrm{e}j} = N_j \frac{\Phi_j(T)/P_\mathrm{e}}{1 + \Phi_j(T)/P_\mathrm{e}} \tag{9.6}&lt;/script&gt;

&lt;p&gt;由理想气体公式，压强为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{\mathrm{e}} = \sum_j N_{\mathrm{e}j}kT&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{g} = \sum_j (N_{\mathrm{e}j} + N_{j})kT \tag{9.7}&lt;/script&gt;

&lt;p&gt;所以压强之比为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align} \frac{P_\mathrm{e}}{P_\mathrm{g}} &amp;= \frac{\sum_j N_{\mathrm{e}j}kT}{\sum_j (N_{\mathrm{e}j} + N_{j})kT} \\ &amp;= \frac{\sum_j N_j [\frac{\Phi_j(T)/P_\mathrm{e}}{1 + \Phi_j(T)/P_\mathrm{e}}]}{\sum_j N_j [1 +  \frac{\Phi_j(T)/P_\mathrm{e}}{1 + \Phi_j(T)/P_\mathrm{e}}]} \end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;上下同除以单位体积内氢原子数量&lt;script type=&quot;math/tex&quot;&gt;N_\mathrm{H}&lt;/script&gt;，令&lt;script type=&quot;math/tex&quot;&gt;A_j = N_\mathrm{j}/N_\mathrm{H}&lt;/script&gt;为相对丰度，有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{e} = P_\mathrm{g} \frac{\sum_j A_j [\frac{\Phi_j(T)/P_\mathrm{e}}{1 + \Phi_j(T)/P_\mathrm{e}}]}{\sum_j A_j [1 +  \frac{\Phi_j(T)/P_\mathrm{e}}{1 + \Phi_j(T)/P_\mathrm{e}}]} \tag{9.8}&lt;/script&gt;

&lt;p&gt;这是一个超越方程，同样也需要迭代对于每一个光深的值去解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，我们能看出高温时&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g} \approx 2P_\mathrm{e}&lt;/script&gt;，或者&lt;script type=&quot;math/tex&quot;&gt;\log{P_\mathrm{g}} \approx \log{P_\mathrm{e}} + 0.3&lt;/script&gt;（因为氢基本上电离了），低温时&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{e} \approx P_\mathrm{g}^{1/2}&lt;/script&gt;，或者&lt;script type=&quot;math/tex&quot;&gt;\log{P_\mathrm{e}} \approx 0.5 \log{P_\mathrm{g}}&lt;/script&gt;。低温这个结论也可以从公式中推出来。先认为恒星大气中只由一种元素的原子组成，则&lt;script type=&quot;math/tex&quot;&gt;(9.8)&lt;/script&gt;变为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{e} = P_\mathrm{g} \frac{\Phi(T)/P_\mathrm{e}}{1 + 2\Phi(T)/P_\mathrm{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Rightarrow P_\mathrm{e}^2 = \Phi(T)(P_\mathrm{g} - 2P_\mathrm{e})&lt;/script&gt;

&lt;p&gt;低温时&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{e} \ll P_\mathrm{g}&lt;/script&gt;，所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{e}^2 \approx \Phi(T)P_\mathrm{g} \tag{9.9}&lt;/script&gt;

&lt;p&gt;低温恒星在迭代的时候还要注意元素丰度的问题，因为这个时候金属元素提供了主要的电子，迭代的时候可能也需要修改元素丰度。&lt;/p&gt;

&lt;h3 id=&quot;模型小结&quot;&gt;模型小结&lt;/h3&gt;

&lt;p&gt;我们已经可以计算大气模型了。拿已经有了的&lt;script type=&quot;math/tex&quot;&gt;T(\tau_0)&lt;/script&gt;和猜测的&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}(\tau_0)&lt;/script&gt;计算&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{e}(\tau_0)&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;\kappa_0(\tau_0)&lt;/script&gt;，然后通过&lt;script type=&quot;math/tex&quot;&gt;(9.2)&lt;/script&gt;算出一个新的&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}(\tau_0)&lt;/script&gt;，如此重复。如果&lt;script type=&quot;math/tex&quot;&gt;T(\tau_0)&lt;/script&gt;是从太阳的转换来的话那收敛之后就完了；但如果&lt;script type=&quot;math/tex&quot;&gt;T(\tau_0)&lt;/script&gt;是理论值的话我们还要求它满足流量守恒，修正&lt;script type=&quot;math/tex&quot;&gt;T(\tau_0)&lt;/script&gt;然后再重复。&lt;/p&gt;

&lt;h3 id=&quot;从模型中导出来的东西&quot;&gt;从模型中导出来的东西&lt;/h3&gt;

&lt;h5 id=&quot;几何深度&quot;&gt;几何深度&lt;/h5&gt;

&lt;p&gt;几何深度就是&lt;script type=&quot;math/tex&quot;&gt;dx = d\tau_0 / \kappa_0 \rho&lt;/script&gt;啦，所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x(\tau_0) = \int_0^{\tau_0} \frac{1}{\kappa(t_0)\rho(t_0)} dt_0 \tag{9.10}&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\kappa&lt;/script&gt;已经在刚刚的迭代中确定了，&lt;script type=&quot;math/tex&quot;&gt;\rho&lt;/script&gt;可以算出来：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\rho = N_\mathrm{H} \times \sum A_j \mu_j&lt;/script&gt;

&lt;p&gt;同时&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;N_\mathrm{H} = \frac{N - N_\mathrm{e}}{\sum A_j} = \frac{P_\mathrm{g} - P_\mathrm{e}}{kT\sum A_j}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Rightarrow x(\tau_0) = \int_0^{\log{\tau_0}} \frac{kT(t_0)\sum A_jt_0}{\kappa(t_0) \sum A_j\mu_j[P_\mathrm{g} - P_\mathrm{e}]\log{e}} d\log{t_0} \tag{9.11}&lt;/script&gt;

&lt;p&gt;或者利用本文第一条公式&lt;script type=&quot;math/tex&quot;&gt;dP_\mathrm{g} = \rho g dx&lt;/script&gt;积分，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x(P_\mathrm{g}) = \frac{1}{g} \int_0^{P_\mathrm{g}} \frac{kT(p)\sum A_j}{\sum A_j\mu_j} \frac{dp}{p-P_\mathrm{e}} \tag{9.12}&lt;/script&gt;

&lt;p&gt;从这里我们可以看到恒星大气的几何深度和&lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;是成反比的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;模型的计算&quot;&gt;模型的计算&lt;/h5&gt;

&lt;p&gt;模型最重要的结果自然是光谱，或者说是不同波长上的流量。这个东西可以从&lt;script type=&quot;math/tex&quot;&gt;(7.15)&lt;/script&gt;计算出来：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_\nu = 2\pi \int_{-\infty}^{\infty} S_\nu(\tau_0) E_2(\tau_\nu) \frac{\kappa_\nu(\tau_0)\tau_0 d\log{\tau_0}}{\kappa_0(\tau_0)\log{e}} \tag{9.13}&lt;/script&gt;

&lt;p&gt;这条式子和&lt;script type=&quot;math/tex&quot;&gt;(7.15)&lt;/script&gt;的区别在于&lt;script type=&quot;math/tex&quot;&gt;S_\nu&lt;/script&gt;以及&lt;script type=&quot;math/tex&quot;&gt;d \tau_\nu&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;S_\nu&lt;/script&gt;的自变量被改成了&lt;script type=&quot;math/tex&quot;&gt;\tau_\nu&lt;/script&gt;，这是因为热动平衡下&lt;script type=&quot;math/tex&quot;&gt;S_\nu(\tau_\nu) = B_\nu[T(\tau_\nu)]&lt;/script&gt;，当我们在讨论同一个几何深度的薄层时无论用的自变量是&lt;script type=&quot;math/tex&quot;&gt;\tau_\nu&lt;/script&gt;还是&lt;script type=&quot;math/tex&quot;&gt;\tau_0&lt;/script&gt;，所表达的温度都是一样的（因为是同一层），所以方便起见我们用&lt;script type=&quot;math/tex&quot;&gt;\tau_0&lt;/script&gt;。要注意的是&lt;script type=&quot;math/tex&quot;&gt;E_2&lt;/script&gt;不能这样做，因为&lt;script type=&quot;math/tex&quot;&gt;E_2&lt;/script&gt;是一个积分，整个积分是随着&lt;script type=&quot;math/tex&quot;&gt;\tau_\nu&lt;/script&gt;的变化而变化的。&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;d \tau_\nu&lt;/script&gt;的话根据几何深度的定义，我们有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;dx = \frac{d\tau_\nu}{\kappa_\nu \rho} = \frac{d\tau_0}{\kappa_0 \rho}&lt;/script&gt;

&lt;p&gt;代进去再换成log scale，就有了最后的那坨东西。&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(9.13)&lt;/script&gt;式的微分是恒星某一层在某个波长上发出的光的流量多少，我们将他称为flux contribution function。它说明了在这个波长下，恒星的光主要是从哪一层发出来的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图我们可以看出8000埃处的恒星光主要来自更高的位置，说明了&lt;script type=&quot;math/tex&quot;&gt;\kappa_{8000}&lt;/script&gt;更大。&lt;/p&gt;

&lt;p&gt;另一个明显的例子是巴尔末跳跃前后的flux contribution function。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到3646的辐射层远高于3648，说明多数的3646辐射都被氢原子吸收掉了。&lt;/p&gt;

&lt;p&gt;以上讨论的主要是&lt;script type=&quot;math/tex&quot;&gt;E_2&lt;/script&gt;对FCF的影响，同时源函数（其实也就是温度分度分布）对FCF也有影响。温度越高，辐射越多，辐射峰值也稍微往高处走（因为温度会使吸收系数发生变化）。&lt;/p&gt;

&lt;p&gt;最后，我们还有别的方法去计算流量，比如对&lt;script type=&quot;math/tex&quot;&gt;(7.15)&lt;/script&gt;的另一种积分：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_\nu = \pi S_\nu(0) + 2\pi \int_0^\infty \frac{dS}{d\tau_\nu}E_3(\tau_\nu)d \tau_\nu&lt;/script&gt;

&lt;p&gt;它和边界的流量以及源函数的梯度有关。&lt;/p&gt;

&lt;h5 id=&quot;模型的性质压强关系&quot;&gt;模型的性质：压强关系&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图9.12显示了气体压强和温度的关系&lt;script type=&quot;math/tex&quot;&gt;T(P_g)&lt;/script&gt;。可以看到不同温度下的曲线并不像&lt;script type=&quot;math/tex&quot;&gt;T(\tau_0)&lt;/script&gt;一样可以直接乘上一个常数；这是我们用光深而不用气体压强做自变量的一个原因（不方便）。&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(7.39)&lt;/script&gt;表明了当上图的斜率超过&lt;script type=&quot;math/tex&quot;&gt;1-1/\gamma \approx 0.4&lt;/script&gt;的时候，会发生对流。所以很多模型到了这里附近会不稳定，需要加入对流的因素。一件好事是对流一般发生在恒星大气的底部，因为大气比较稀薄的时候主要还是辐射传能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.13.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/in-post/post-OASP9/9.14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图9.13和9.14显示了两个不同温度的模型在不同光深处的气体以及电子压强。在低温模型的大气上层，电子压强远远小于气体压强；向恒星内部走，温度升高使得电离增强，所以电子压强也升高，但是仍然没有完全电离。对于高温恒星，两条线距离很小，意味着基本上完全电离了。&lt;/p&gt;

&lt;p&gt;我们还可以看看表面重力加速度和压强的关系。由&lt;script type=&quot;math/tex&quot;&gt;(9.2)&lt;/script&gt;，我们有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{g} \approx C(T) g^{2/3} \tag{9.19}&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;C(T)&lt;/script&gt;就是那一堆积分加常数。然后从&lt;script type=&quot;math/tex&quot;&gt;(9.9)&lt;/script&gt;，对于低温模型，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{e} \approx \text{constant}\, g^{1/3} \tag{9.20}&lt;/script&gt;

&lt;p&gt;高温模型下因为&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{e} \approx 0.5 P_\mathrm{g}&lt;/script&gt;，所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{e} \approx \text{constant}\, g^{2/3} \tag{9.21}&lt;/script&gt;

&lt;p&gt;这个结论是和计算一致的。&lt;/p&gt;

&lt;h5 id=&quot;金属丰度的影响&quot;&gt;金属丰度的影响&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.15.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/in-post/post-OASP9/9.16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图9.15和9.16显示了低温模型不同金属丰度下气体压强的情况。高温模型的话主要是氢原子提供电子，同时压强也和金属丰度关系不大了。对于低温恒星，金属丰度越大、电子压强也越大。这是显而易见的，因为更多的金属提供了更多的电子。当然在大气底层，增大金属丰度对电子压强影响不大，因为此时（又）主要是由氢原子提供电子了，也不在乎金属提供的那点电子。稍微不那么好理解的是气体压强，为什么金属丰度增大之后气体压强反而减小了呢？这不是因为气体压强本身的问题，而是电子增多带来的不透明度增大。电子增多会带来更大的连续谱吸收，导致同一个几何深度上的光深变大，所以我们看到的恒星大气厚度变小，整条线右移、气体压强自然就“减小”了。&lt;/p&gt;

&lt;p&gt;当然这可以用公式推出来；我们计算这么一个量：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{P_\mathrm{e}}{P_\mathrm{g}}\frac{1}{\sum A_j} = \frac{P_\mathrm{e}}{P_\mathrm{g}} \frac{N_\mathrm{H}}{\sum N_J} \frac{kT}{kT} = \frac{P_\mathrm{e}}{P_\mathrm{g}} \frac{P_\mathrm{H}}{\sum N_j kT} \approx \frac{P_\mathrm{e}}{\sum N_j kT}&lt;/script&gt;

&lt;p&gt;恒星里面主要是氢嘛，所以&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{H}&lt;/script&gt;就近似相等了。继续，&lt;script type=&quot;math/tex&quot;&gt;N_j&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{e}&lt;/script&gt;可以表述为原子离子的组合：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum N_j = \sum (N_1+N_0)_j, P_\mathrm{e} = N_\mathrm{e}kT = \sum N_{1j}kT&lt;/script&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{P_\mathrm{e}}{P_\mathrm{g}}\frac{1}{\sum A_j} \approx \frac{\sum N_{1j}}{\sum (N_1+N_0)_j}&lt;/script&gt;

&lt;p&gt;那么当金属基本上被电离的时候，&lt;script type=&quot;math/tex&quot;&gt;\sum N_{1j} \gg \sum N_{0j}&lt;/script&gt;：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{P_\mathrm{e}}{P_\mathrm{g}}\frac{1}{\sum A_j} \approx 1 \tag{9.22}&lt;/script&gt;

&lt;p&gt;金属处于中性的时候，&lt;script type=&quot;math/tex&quot;&gt;\sum N_{1j} \ll \sum (N_{1j} + N_{0j})&lt;/script&gt;：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{P_\mathrm{e}}{P_\mathrm{g}}\frac{1}{\sum A_j} \approx \frac{\sum N_{1j}}{\sum N_{0j}} \tag{9.23}&lt;/script&gt;

&lt;p&gt;在金属电离的情况下，&lt;script type=&quot;math/tex&quot;&gt;(9.1)&lt;/script&gt;可以写成：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;d P_\mathrm{g} = \frac{g}{\kappa_0}d\tau_0 = \frac{g}{P_\mathrm{e}\kappa_0/P_\mathrm{e}}d\tau_0 = \frac{g}{P_\mathrm{g}\sum A_j \kappa_0/P_\mathrm{e}}d\tau_0&lt;/script&gt;

&lt;p&gt;对&lt;script type=&quot;math/tex&quot;&gt;P_\mathrm{g}&lt;/script&gt;积分，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{2} P_\mathrm{g}^2 = \frac{1}{\sum A_j} \int_0^{\tau_0} \frac{g}{\kappa_0 / P_\mathrm{e}} d\tau_0&lt;/script&gt;

&lt;p&gt;把后面的积分当作常数，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{g} = c_0 (\sum A_j)^{-1/2} \tag{9.24}&lt;/script&gt;

&lt;p&gt;然后从&lt;script type=&quot;math/tex&quot;&gt;(9.22)&lt;/script&gt;有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{e} = c_0 (\sum A_j)^{1/2} \tag{9.25}&lt;/script&gt;

&lt;p&gt;当然这只是一个定性的估算，而且只在大气外部成立。&lt;/p&gt;

&lt;p&gt;在金属中性的情况下，只考虑一种金属使得&lt;script type=&quot;math/tex&quot;&gt;N_1/N_0 = \Phi(T)/P_\mathrm{e}&lt;/script&gt;，则有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{g} = c_1 (\sum A_j)^{-1/3}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{e} = c_1 (\sum A_j)^{1/3}&lt;/script&gt;

&lt;p&gt;我们还可以比较一下图9.13和9.16，可以发现在恒星大气顶部，增大金属丰度和增大&lt;script type=&quot;math/tex&quot;&gt;\log{g}&lt;/script&gt;对电子压强的影响是类似的，所以这两个物理量同向变化的时候对大气顶端的光谱特征的影响也是类似的。也就是说从光谱特征的变化我们分不出究竟是金属丰度还是&lt;script type=&quot;math/tex&quot;&gt;\log{g}&lt;/script&gt;变大/变小了。&lt;/p&gt;

&lt;p&gt;氦元素丰度也可以稍微使得压强发生变化。利用&lt;script type=&quot;math/tex&quot;&gt;(8.19)&lt;/script&gt;我们可以将&lt;script type=&quot;math/tex&quot;&gt;(9.1)&lt;/script&gt;写成&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;dP_\mathrm{g} = \frac{g}{\kappa_0}d\tau_0 = \frac{g}{\kappa}\sum A_j \mu_j d\tau_0&lt;/script&gt;

&lt;p&gt;从这里我们能看到&lt;script type=&quot;math/tex&quot;&gt;\sum A_j \mu_j&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;的地位是相似的，所以根据&lt;script type=&quot;math/tex&quot;&gt;(9.19)&lt;/script&gt;有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{g} = \text{constant} (\sum A_j \mu_j)^{2/3}&lt;/script&gt;

&lt;p&gt;同时&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum A_j \mu_j = A(\mathrm{H})\mu_\mathrm{H} + A(\mathrm{He})\mu_\mathrm{He} + ... \approx 1.66\times 10^{-24} [1+4A(\mathrm{He})]&lt;/script&gt;

&lt;p&gt;我们又忽略了其他元素。所以类似的，有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mathrm{g} = \text{constant} [1+4A(\mathrm{He})]^{2/3}&lt;/script&gt;

&lt;p&gt;至于电子压强，代进&lt;script type=&quot;math/tex&quot;&gt;(9.9)&lt;/script&gt;附近的结论就行了。&lt;/p&gt;

&lt;h5 id=&quot;压强和有效温度的关系&quot;&gt;压强和有效温度的关系&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-OASP9/9.17.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/in-post/post-OASP9/9.18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;继续看图说话，9.17和9.18。我们只看大气的某一层，对于电子压强来说提高温度自然有更多电子出来，所以成正比，直到氢被电离为止。正比的那一段可以用一条直线来拟合；而气体压强就和图9.15类似了，因为电子多了所以看不深，只能看到外面压强，就小了。&lt;/p&gt;

&lt;h4 id=&quot;复习&quot;&gt;复习&lt;/h4&gt;

&lt;p&gt;够长的一章。这里所提及的模型都是很简单的，只要确定了有效温度、&lt;script type=&quot;math/tex&quot;&gt;\log{g}&lt;/script&gt;和金属丰度的话就可以完全确定。放松最开始提到的假设可以造出更符合实际（或者需要）的模型，这个会在之后提到。&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Mar 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/03/08/OASP9/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/08/OASP9/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>Jupyter Notebook + Python 备忘</title>
        <description>&lt;h2 id=&quot;catagory&quot;&gt;Catagory&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#jpynb&quot;&gt;Jpynb备忘&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#jpynb-color_change&quot;&gt;改变Notebook里面Markdown文字颜色&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jpynb-theta&quot;&gt;Matplotlib中&lt;code class=&quot;highlighter-rouge&quot;&gt;'\theta'&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;heta&lt;/code&gt;的问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#py&quot;&gt;Python备忘&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#py-array_stack&quot;&gt;Numpy中的矩阵合并&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#py-package&quot;&gt;自己写包&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Pandas&lt;/li&gt;
  &lt;li&gt;matplotlib&lt;/li&gt;
&lt;/ol&gt;

&lt;p id=&quot;jpynb&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;jpynb备忘&quot;&gt;Jpynb备忘&lt;/h3&gt;

&lt;p id=&quot;jpynb-color_change&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;改变notebook里面markdown文字颜色&quot;&gt;改变Notebook里面Markdown文字颜色&lt;/h4&gt;

&lt;p&gt;例如想要这样的效果：foo &lt;font color=&quot;red&quot;&gt; bar &lt;/font&gt; foo&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo &amp;lt;font color='red'&amp;gt; bar &amp;lt;/font&amp;gt; foo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其实就是一个HTML的attribute。&lt;/p&gt;

&lt;p id=&quot;jpynb-theta&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;matplotlib中theta变为heta的问题&quot;&gt;Matplotlib中&lt;code class=&quot;highlighter-rouge&quot;&gt;'\theta'&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;heta&lt;/code&gt;的问题&lt;/h4&gt;

&lt;p&gt;这是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;\t&lt;/code&gt;在字符串中会被转义为Tab，所以要在字符串前加上一个&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;。&lt;/p&gt;

&lt;p id=&quot;py&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;python备忘&quot;&gt;Python备忘&lt;/h3&gt;

&lt;p id=&quot;py-array_stack&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;numpy中的矩阵合并&quot;&gt;Numpy中的矩阵合并&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;列合并/扩展：np.column_stack()&lt;/li&gt;
  &lt;li&gt;行合并/扩展：np.row_stack()&lt;/li&gt;
&lt;/ul&gt;

&lt;p id=&quot;py-pandas&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;pandas&quot;&gt;Pandas&lt;/h4&gt;

&lt;p&gt;DataFrame里面选出几列：&lt;code class=&quot;highlighter-rouge&quot;&gt;df[['a', 'b']]&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;从pdf中提取表格&quot;&gt;从pdf中提取表格&lt;/h4&gt;
&lt;p&gt;先安装tabula-py：
&lt;code class=&quot;highlighter-rouge&quot;&gt;pip install tablua-py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;导入，使用：&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tabula&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tabula&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_pdf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xxx.pdf'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'--pages 4'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p id=&quot;py-package&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;自己写包&quot;&gt;自己写包&lt;/h4&gt;

&lt;p&gt;一直都想这么干了，之前的代码都是复制粘贴，觉得很没有效率；所以决定将常用的代码写成一个包方便调用。目标是想numpy一样有层级，同时只导入包名能用Tab提示下面层级的内容。&lt;/p&gt;

&lt;p&gt;首先描述文件结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\ruler
  \ruler
    __init__.py
    convert.py
    \subpackage
      __init__.py
      something.py
  setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为还没完全写好，就先把一个示例放上来。最外面的ruler是安装用的，不叫包名应该也可以（但是如果要上传到PyPi的话应该有要求），里面的setup.py需要有这样的内容：&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;setuptools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ruler'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'0.1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'The ruler for spectra'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Mingjie Jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;author_email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ssaajianmingjie@gmail.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;license&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'MIT'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ruler'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;zip_safe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果只有&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;的话可能也行。第二层的ruler是真正的包，它以及里面的每个文件夹都需要有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;__init__.py&lt;/code&gt;，表示这是包。从这一级开始里面就可以放module，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;.py&lt;/code&gt;文件了。不过要达到之前的目的（仅import包名但自动提示模块）需要在每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;__init__.py&lt;/code&gt;里面将对应文件夹包含的module以及子文件夹们import掉；比如ruler里面的要这样写：&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;convert&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subpackage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然subpackage里面的也需要这样写才能把所有的module都带上。想要测试的话先import然后用&lt;code class=&quot;highlighter-rouge&quot;&gt;dir()&lt;/code&gt;看看module和子文件夹在不在里面就行。&lt;/p&gt;

&lt;p&gt;这些搞定之后就可以跑回最外级的ruler里面打开终端，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;pip install -e .&lt;/code&gt;。暂时不知道为什么，但是这种方法可以直接在Jpynb里面用，把Jpynb重启一遍就行了。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://docs.python.org/3/tutorial/modules.html#packages&quot;&gt;Python Tutorial Chap. 6&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://python-packaging.readthedocs.io/en/latest/index.html&quot;&gt;How To Package Your Python Code&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://codingpy.com/article/python-import-101/&quot;&gt;Python导入模块的几种姿势&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;pandas-1&quot;&gt;Pandas&lt;/h4&gt;

&lt;h5 id=&quot;读取固定宽度表格&quot;&gt;读取固定宽度表格&lt;/h5&gt;
&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_fwf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'catalog/Kovtyukh/Kovtyukh04/table1.dat'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                           &lt;span class=&quot;n&quot;&gt;colspecs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;46&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;47&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;53&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;68&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)],&lt;/span&gt;
                           &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Star'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Teff'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'N'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'e_Teff'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'logg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Vt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'[Fe/H]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'VMAG'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                  &lt;span class=&quot;s&quot;&gt;'B-V'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Rem'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;matplotlib&quot;&gt;Matplotlib&lt;/h4&gt;

&lt;h5 id=&quot;防止重叠或者出边界&quot;&gt;防止重叠或者出边界&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;plt.tight_layout()&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/01/29/jpynb/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/29/jpynb/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>Bash 备忘</title>
        <description>&lt;h2 id=&quot;catagory&quot;&gt;Catagory&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#jpynb&quot;&gt;Jpynb备忘&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#jpynb-color_change&quot;&gt;改变Notebook里面Markdown文字颜色&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jpynb-theta&quot;&gt;Matplotlib中&lt;code class=&quot;highlighter-rouge&quot;&gt;'\theta'&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;heta&lt;/code&gt;的问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#py&quot;&gt;Python备忘&lt;/a&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#py-array_stack&quot;&gt;Numpy中的矩阵合并&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#py-package&quot;&gt;自己写包&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p id=&quot;jpynb&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -1 -d */*/* | sed -e 's/\// /g' -e 's/_pipeline/ pipeline/'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;合并pdf
&lt;code class=&quot;highlighter-rouge&quot;&gt;pdftk file1.pdf file2.pdf cat output mergedfile.pdf&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/01/29/bash/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/29/bash/</guid>
        
        <category>learning</category>
        
        
      </item>
    
      <item>
        <title>箱根探路者</title>
        <description>&lt;p&gt;箱根是我一直想去的地方，一是因为在那能看见富士山，第二是那里是新世纪福音战士第三新东京市的原型。正好这周想出去逛逛（当然发现switch入货是临时的事情），来实习的诺亚同学也刚好错过了松永组织的镰仓社寺一日游（真的全是社寺），就拉上他一起去那看看了。当然也有踩点的意思，毕竟下个月打算还来一次。&lt;/p&gt;

&lt;h3 id=&quot;大致路线&quot;&gt;大致路线&lt;/h3&gt;

&lt;p&gt;因为只能去一天，所以基本上是按照小田急给出的示范行程来走的，从箱根汤本一路往西经过强罗、大涌谷到达桃源台港，然后坐船穿过芦之湖到达箱根町和元箱根，稍作参观之后坐巴士回到箱根汤本，終了。一路的交通都是挺方便的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/hakone-route.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;出发之前&quot;&gt;出发之前&lt;/h3&gt;

&lt;p&gt;东京到箱根的交通大致分为两类：不使用JR和使用JR。一般不使用JR的方式是在新宿站购买小田急的箱根Free Pass（箱根フリーパス）并预约来回的特急“浪漫特快”（ロマンスカー），这样可以解决全部在箱根的交通问题和一大部分的景点门票。从新宿出发的2日箱根Free Pass是5140日元（儿童是1500），购买Free Pass之后单程的浪漫特快还需要加890日元，所以一共是6920日元。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/freepass-price.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Free Pass只有两天和三天的选择，所以即使只去一天也需要买两天的。不过这么一圈坐下来如果不买Pass的话大概是六千多日元，而且有Pass的话上下车相对自由一点。这些票都可以在新宿或者小田原的小田急窗口处购买。&lt;/p&gt;

&lt;p&gt;如果有JR Pass的话也可以选择乘坐JR到小田原再转箱根登山铁道到箱根汤本。上面最后一行写的就是在小田原购买箱根Free Pass的价格；如果不购买的话交通费大概是四千七日元，所以也还是买Pass便宜一点。&lt;/p&gt;

&lt;h3 id=&quot;特急浪漫特快&quot;&gt;特急“浪漫特快”&lt;/h3&gt;

&lt;p&gt;开往箱根汤本的浪漫特快无论工作日还是周末都是从7点钟开始首发，平均下来大概半个小时一班的样子。不住在新宿附近的话周末选择7:30、8:00、8:30或者9:00的比较合适，工作日的话就是7:00、7:27或者8:53了。（请注意时刻表可能会变，请到&lt;a href=&quot;http://www.odakyu.jp/romancecar/timetable/weekday/&quot;&gt;这里&lt;/a&gt;确认一下）。回来的车基本上都会停新宿，所以选择余地比较大，我觉得晚上7点出发的比较合适。&lt;/p&gt;

&lt;p&gt;时刻表里面带“展”字的车次是有展望席的，车头或者车尾有很大的窗户，适合观景。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/view-seat.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大概是这个样子，司机要爬到上面开车。这些票和旺季（春节？）的特急票都可以在&lt;a href=&quot;https://www.web-odakyu.com/e-romancecar/&quot;&gt;这里&lt;/a&gt;提前预约或者购买。实际上展望席后面还紧接着两个不算展望席的座位，但是位置是和展望席一样的，所以没有预约到展望席又想坐在附近的话不妨在买票的时候问问还有没有展望席的位置。&lt;/p&gt;

&lt;p&gt;浪漫特快虽然叫特快，但是毕竟不是新干线而且过了小田原之后的登山铁道部分只有单线，所以从新宿出发还是需要85分钟的，请带上论文/书/ipad/3DS/Switch等。&lt;/p&gt;

&lt;h3 id=&quot;强罗午饭&quot;&gt;强罗=午饭&lt;/h3&gt;

&lt;p&gt;出于对时间的些许担心，我们决定到了箱根汤本之后马上去强罗。换乘去强罗的登山电车不需要出闸，直接到3号站台坐车就行。虽然从地图上看箱根汤本到强罗并不算远，但是登山电车本来就慢加上路上有三处像京张铁路的人字形轨道，所以整个用时为40分钟。这么下来我们到强罗的时候已经是10点半，该吃午饭了。&lt;/p&gt;

&lt;p&gt;这么早考虑午饭的原因在于想去试试一家比较出名的餐厅，田むら銀かつ亭。很多攻略都推荐了这家餐厅，既然来了就去试试呗。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/resturant.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就是这家。11点开始营业，但是一般10点半开始就会有人来取号，开始营业之后按照号码顺序就餐。我们大概是40到的，已经是11号了。当然吃完之后出来发现还有将近三十个号在排队，看来的确挺出名的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/lunch.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;午饭基本上点的都是招牌套餐，豆腐猪排套餐(1330日元)和御膳(2050日元)。这两种的区别在于后者多了一个甜品、饮料和沙拉，而且后者的猪排下面是有小火一直加热的。我上面点的是套餐，就只有这几样。感觉还挺好吃，不过排队的人数让我觉得里面也有宣传的成分。&lt;/p&gt;

&lt;h3 id=&quot;强罗公园&quot;&gt;强罗公园&lt;/h3&gt;

&lt;p&gt;吃完饭之后走了走附近的强罗公园。冬天能看的不多，也没有雪，就是近处的温泉和远处的火山烟：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/gora-park.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得一提的是公园里面还有两个热带植物馆，可以取暖（误）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/park-flower1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/park-flower2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看到了在南方随处可见的勒杜鹃还有鹤望兰。&lt;/p&gt;

&lt;h3 id=&quot;大涌谷&quot;&gt;大涌谷&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/cable-car.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从强罗公园南门出来左转走一分钟就到了登山缆车的公园下站，等一会就有缆车带着上到早云山了。还是要注意一下发车时刻的，间隔在20分钟左右。本来在早云山可以直接转乘空中缆车到达大涌谷（顺便在空中看看硫磺烟），但是1月16日到2月7日之间早云山-大涌谷之间的&lt;a href=&quot;http://www.hakoneropeway.co.jp/info_img/255_pdf.pdf&quot;&gt;缆车维修&lt;/a&gt;，所以只能坐专用的大巴过去。出战之后跟着大部队走就行了，我们坐的是旅游大巴所以都有位置。&lt;/p&gt;

&lt;p&gt;大涌谷就是火山活动留下来的一直在往外冒烟的山谷，而因为附近硫磺比较多所以空气比较…臭。看还是挺好看的，也有很多吃的和纪念品卖。最出名的应该就是黑色的鸡蛋了，用山上的温泉泡熟，因为水中的成分和鸡蛋壳作用变成了黑色。实际上就是煮鸡蛋，里面没有任何区别。大涌谷本来还有两条登山道，但是我们去的时候因为空气中硫化物含量太高&lt;a href=&quot;http://www.hakoneropeway.co.jp/ohwakudani/&quot;&gt;封闭了&lt;/a&gt;，可惜。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/owakudani.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;芦之湖&quot;&gt;芦之湖&lt;/h3&gt;

&lt;p&gt;整个行程可能最需要注意的就是芦之湖海贼船的&lt;a href=&quot;https://www.hakone-kankosen.co.jp/timesheet/&quot;&gt;时刻表&lt;/a&gt;了，间隔可能会到一个小时左右，所以在大涌谷的时候要留意时间。大涌谷到湖边的桃源台港需要16分钟，也是空中缆车，之后就可以等着船准备坐半个小时了。如果嫌船挤的话可以花500日元买高级舱的票，人就不那么多了（资本主义）。在船上可以看见湖边的鸟居：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/lake-tori.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至于终点到箱根町还是元箱根都没什么所谓，就算是走路也才十来分钟而已，还有巴士来往。&lt;/p&gt;

&lt;h3 id=&quot;箱根町和元箱根&quot;&gt;箱根町和元箱根&lt;/h3&gt;

&lt;p&gt;到这里的时候已经过了四点，天开始黑了，我们就只走了走箱根关所和恩赐箱根公园。这公园原来是天皇避暑的地方，也接待过不少政界要人，但是在之后的两次地震之中塌了75%的楼宇……现在只有一栋楼在那了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/park-tree.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;别的还有箱根神社可以看看，挺大的。晚上路灯亮了之后很有神秘的感觉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-hakone-pathfinder/shrine.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后就是坐巴士回箱根汤本了。在元箱根出发的话R、H和K线都能到箱根汤本，每天的最后一班是R线17:40的车，25分钟到箱根汤本。错过了的话……我不知道了:)&lt;/p&gt;

&lt;h3 id=&quot;回程&quot;&gt;回程&lt;/h3&gt;

&lt;p&gt;回去之后还有一点时间，想逛一下EVA屋但是关门了。这个时候基本上所有的店铺都开始关门了，但是还是可以进去逛一下的；站内的商店没关，但是便当就不一定有了，另外我们坐的19:10的特急没有车内售卖的服务，所以最差的情况可能需要在附近的便利店买点吃的或者看看站台的小卖部有没有了（但是我没有确认过）。回到新宿8点半，时间挺合适。我觉得箱根还是一天比较好，虽然是一天稍微有一点赶，但是两天又感觉景点不够支撑的，没有太特别的理由一天就行。&lt;/p&gt;

&lt;h3 id=&quot;also-read&quot;&gt;Also Read&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.hakonenavi.jp/cn/&quot;&gt;小田急箱根导航&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.marshyfood.com/2015/06/2015.html&quot;&gt;有用的攻略&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/01/22/hakone-pathfinder/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/22/hakone-pathfinder/</guid>
        
        <category>hanging-around</category>
        
        
      </item>
    
      <item>
        <title>如何在Linux上制作延时摄影视频</title>
        <description>&lt;p&gt;在Windows上制作延时摄影有很多软件，AE、LRTimelapse（去闪）之类的；但是Linux上相关的制作软件虽然有，但是并不是很熟悉。隐约感觉Linux肯定能做，而且可以在命令行上面做，但是需要问问谷歌。结果来说的确可以做出来，这里就把相关的软件以及命令记录一下。&lt;/p&gt;

&lt;h3 id=&quot;原材料&quot;&gt;原材料&lt;/h3&gt;

&lt;p&gt;2017年底拍摄的东大赤门的100张照片，间隔大概在1秒左右，jpg格式。&lt;/p&gt;

&lt;h4 id=&quot;if-raw-file&quot;&gt;If raw file&lt;/h4&gt;

&lt;p&gt;https://www.darktable.org/&lt;/p&gt;

&lt;p&gt;批处理：lighttable -&amp;gt; history stack; copy and paste&lt;/p&gt;

&lt;h3 id=&quot;处理jpg文件&quot;&gt;处理jpg文件&lt;/h3&gt;

&lt;p&gt;因为拍摄的时候曝光有点不足，所以需要对每张照片进行亮度和对比度的处理。这里用的是GIMP；如果没有安装过的话先安装GIMP：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install gimp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后安装批处理的插件：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install gimp-plugin-registry&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-time-lapse-linux/batch-open.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装之后打开GIMP，上方菜单栏里面会多了一些栏目。选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Filters - Batch - Batch Process&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-time-lapse-linux/batch-window.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个批处理窗口提供了一些我们需要的功能。选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Add Files&lt;/code&gt;将要处理的照片都添加进去。简单的亮度对比度颜色处理在&lt;code class=&quot;highlighter-rouge&quot;&gt;Colour&lt;/code&gt;里面，选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Enable&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Auto Levels&lt;/code&gt;就可以了。最后在&lt;code class=&quot;highlighter-rouge&quot;&gt;Rename&lt;/code&gt;里面选择要输出的文件夹，需要的话先测试一下(&lt;code class=&quot;highlighter-rouge&quot;&gt;Test&lt;/code&gt;)，觉得没有问题的话&lt;code class=&quot;highlighter-rouge&quot;&gt;Start&lt;/code&gt;就行。处理过程中可能会报错，但是只要能成功输出就不用管了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-time-lapse-linux/comp.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;处理前后的对比&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;将jpg转换成视频&quot;&gt;将jpg转换成视频&lt;/h3&gt;

&lt;p&gt;所以我们现在有了一堆处理过的jpg文件，之后只要把它们拼成视频就行了。这一步需要保证文件的顺序是正确的，也就是没有从999到001的情况。如果有的话需要将它们按照正确的顺序重命名。另一个需要注意的细节是可以通过命令调节输出视频的分辨率，不过我一般按照源片的分辨率来，也不用调整了。拼合的命令如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg -r 24 -pattern_type glob -i '*.jpg' -c:v copy output.avi&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;后面的数字是帧数，可以随意调整，最后的&lt;code class=&quot;highlighter-rouge&quot;&gt;output.avi&lt;/code&gt;是输出的文件名字。我还没试过其他的格式，而这个命令会原原本本地将照片拼到一个视频里面，所以这个视频是没有被压缩过的，占用的空间和照片们的空间一样。&lt;/p&gt;

&lt;p&gt;这里的视频大小是2.2G，只是100张照片。当然这个大小不能轻易地放到网上去共享，所以我们进行压缩：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg -i MVI_7274.MOV -vcodec libx264 -preset fast -crf 20 -y -vf &quot;scale=1920:-1&quot; -acodec libmp3lame -ab 128k a.mp4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参考链接里面有很详细的介绍，这里不赘述了。最重要的是&lt;code class=&quot;highlighter-rouge&quot;&gt;-crf&lt;/code&gt;后面的参数，数字越小视频质量越高。可以多试几个不同的数字然后取合适的大小和质量。最后的视频如下：&lt;/p&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;/img/in-post/post-time-lapse-linux/cloud_tl.mp4&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;闲话&quot;&gt;闲话&lt;/h3&gt;

&lt;p&gt;刚刚想到其实也有别的思路，比如在GIMP编辑照片的时候将分辨率降低，那么占用的空间和后续处理时间都会变小。另外GIMP也有命令行模式，应该可以更细致地控制参数；不过稍微有点复杂，还需要研究一下。&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://ubuntuforums.org/showthread.php?t=2022316&quot;&gt;jpg转成视频&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002502526&quot;&gt;视频压缩&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Jan 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2018/01/21/time-lapse-linux/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/21/time-lapse-linux/</guid>
        
        <category>experience</category>
        
        
      </item>
    
  </channel>
</rss>
